var threeD =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/app.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack://threeD/./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://threeD/(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/app.js":
/*!********************!*\
  !*** ./src/app.js ***!
  \********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var es6_tween__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! es6-tween */ \"C:\\\\Users\\\\XiaoMi\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\es6-tween\\\\bundled\\\\Tween.min.js\");\n/* harmony import */ var es6_tween__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(es6_tween__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var three_examples_jsm_libs_stats_module_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three/examples/jsm/libs/stats.module.js */ \"C:\\\\Users\\\\XiaoMi\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\three\\\\examples\\\\jsm\\\\libs\\\\stats.module.js\");\n/* harmony import */ var _v2_geometry_utils_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./v2_geometry/utils/constants */ \"./src/v2_geometry/utils/constants.js\");\n/* harmony import */ var _v2_geometry_utils_constants__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_v2_geometry_utils_constants__WEBPACK_IMPORTED_MODULE_2__);\nvar GEO2 = __webpack_require__(/*! ./v2_geometry/GEO2 */ \"./src/v2_geometry/GEO2.js\");\n\n\n\nvar WebFont = __webpack_require__(/*! webfontloader */ \"C:\\\\Users\\\\XiaoMi\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\webfontloader\\\\webfontloader.js\");\n\nObject(es6_tween__WEBPACK_IMPORTED_MODULE_0__[\"autoPlay\"])(true);\n\nvar funcs = __webpack_require__(/*! ./v2_geometry/utils/funcs */ \"./src/v2_geometry/utils/funcs.js\");\n\n\n\nvar stats = new three_examples_jsm_libs_stats_module_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\nvar toolbarTop = document.getElementById(\"toolbar_top\"); // toolbarTop.appendChild(stats.dom);\n\nvar stage = new GEO2.Stage(\"container_2d\");\nvar grid = stage.getGrid();\nvar point = new GEO2.Point({\n  x: 0,\n  y: 0\n});\ngrid.addItem(point);\nvar circle = new GEO2.Circle({\n  x: 1,\n  y: 0\n}, 2);\ngrid.addItem(circle); // let Triangle = new GEO2.Triangle(pt1, pt2, pt3, { color: \"#\" + ((1 << 24) * Math.random() | 0).toString(16) });\n// grid.addItem(Triangle);\n// let vector = new GEO2.Vector({ x: 0, y: 0 }, { x: 1, y: 1 }, { color: \"#ff0000\" });\n// grid.addItem(vector);\n// setTimeout(\n//     updateVector\n// , 2000)\n// function updateVector() {\n//     let x1 = Math.random() * 4;\n//     let x2 = Math.random() * 4;\n//     let y1 = Math.random() * 4;\n//     let y2 = Math.random() * 4;\n//     vector.update({ x: x1, y: y1 }, { x: x2, y: y2 })\n//     setTimeout(\n//         updateVector\n//     , 2000)\n// }\n// let angle = new GEO2.Angle(pt3, pt2, pt2, pt1);\n// grid.addItem(angle);\n// let angle1 = new GEO2.Angle(pt2, pt1, pt1, pt3);\n// grid.addItem(angle1);\n// let angle2 = new GEO2.Angle(pt1, pt3, pt3, pt2);\n// grid.addItem(angle2);\n\nvar layer = new GEO2.Layer();\nstage.addLayer(layer); // let clock = new GEO2.Clock();\n// layer.addItem(clock);\n\nvar protractor = new GEO2.Protractor({\n  color: \"#\" + ((1 << 24) * Math.random() | 0).toString(16)\n});\ngrid.addItem(protractor); // protractor.prepareToMesure({x: 3.0217318687883754, y: -2.8480282628387155}, {x : -2.4250967591063244, y: -2.745688784486169},  0.7439556396789873);\n// protractor.prepareToMesure({x: -2.718445040081332, y: -4.448715929888236}, {x: 1.7547699383660316, y: -1.1373260613833747},  1.0843175043185154);\n\nvar ruler = new GEO2.Ruler({\n  color: \"#\" + ((1 << 24) * Math.random() | 0).toString(16)\n}); // let ruler = new GEO2.Ruler({ color: \"#3b84dd\"});\n\ngrid.addItem(ruler);\nvar pencil = new GEO2.Pencil();\ngrid.addItem(pencil);\nvar aniId;\n\nfunction animate() {\n  aniId = requestAnimationFrame(animate); // stats.update();\n\n  stage.render();\n}\n\nvar btnStop1 = document.getElementById(\"btnStop1\");\nbtnStop1.addEventListener('click', function (evt) {\n  // ruler.hide();\n  // circle.select()\n  var x1 = -5 + Math.random() * 10;\n  var x2 = -5 + Math.random() * 10;\n  var y1 = -5 + Math.random() * 10;\n  var y2 = -5 + Math.random() * 10;\n  var ang = -Math.PI + Math.random() * _v2_geometry_utils_constants__WEBPACK_IMPORTED_MODULE_2___default.a.TWO_PI; // protractor.prepareToMesure({x: 0.8321698978497487, y: 3.30474767711938}, {x: -4.749613449408187, y: -1.2183228775597654}, 0.8484547274140293);\n\n  protractor.prepareToMesure({\n    x: x1,\n    y: y1\n  }, {\n    x: x2,\n    y: y2\n  }, ang);\n  return; // let newPoint = new GEO2.Point({ x: (Math.random() * 8) - 4, y: (Math.random() * 8) - 4 }, { color: \"#\" + ((1 << 24) * Math.random() | 0).toString(16) });\n  // grid.addItem(newPoint);\n  // ruler.measure(line.startPt, line.endPt);\n  // pencil.prepareToDrawLine(line.startPt, line.endPt, () => {\n  //     line.draw((endPt) => { // endpt in coordinate...\n  //         pencil.move(endPt);\n  //     }, () => {\n  //         pencil.hide(300);\n  //         ruler.hide(300);\n  //     });\n  // });\n  // let x1 = -5 + Math.random() * 10;\n  // let x2 = -5 + Math.random() * 10;\n  // let y1 = -5 + Math.random() * 10;\n  // let y2 = -5 + Math.random() * 10;\n  // let ang = -Math.PI + Math.random() * constants.TWO_PI;\n  // protractor.prepareToMesure({ x : x1, y : y1}, {x : x2, y : y2}, ang)\n  // return;\n  // let x1 = -5 + Math.random() * 10;\n  // let x2 = -5 + Math.random() * 10;\n  // let x3 = -5 + Math.random() * 10;\n  // let y1 = -5 + Math.random() * 10;\n  // let y2 = -5 + Math.random() * 10;\n  // let y3 = -5 + Math.random() * 10;\n\n  var pt1 = new GEO2.Vector2(-2.6, 2);\n  var pt2 = new GEO2.Vector2(-1.8, -3.4);\n  var pt3 = new GEO2.Vector2(0.1, 2.5); // let pt1 = new GEO2.Vector2(x1, y1)\n  // let pt2 = new GEO2.Vector2(x2, y2)\n  // let pt3 = new GEO2.Vector2(x3, y3)\n\n  var line = new GEO2.Line(pt1.clone(), pt2.clone(), {\n    autoDraw: false\n  });\n  grid.addItem(line);\n  ruler.moveTo(pt1, pt2, function () {\n    pencil.prepareToDrawLine(pt1, pt2, function () {\n      line.draw(function (endPt) {\n        // endpt in coordinate...\n        pencil.move(endPt);\n      }, function () {\n        drawLine2();\n      });\n    });\n  }, 500);\n\n  var drawLine2 = function drawLine2() {\n    var line = new GEO2.Line(pt2.clone(), pt3.clone(), {\n      autoDraw: false\n    });\n    grid.addItem(line);\n    pencil.hide();\n    ruler.moveTo(pt2, pt3, function () {\n      pencil.prepareToDrawLine(pt2, pt3, function () {\n        line.draw(function (endPt) {\n          // endpt in coordinate...\n          pencil.move(endPt);\n        }, function () {\n          drawLine3();\n        });\n      });\n    }, 500);\n  };\n\n  var drawLine3 = function drawLine3() {\n    var line = new GEO2.Line(pt3.clone(), pt1.clone(), {\n      autoDraw: false\n    });\n    grid.addItem(line);\n    pencil.hide();\n    ruler.moveTo(pt3, pt1, function () {\n      pencil.prepareToDrawLine(pt3, pt1, function () {\n        line.draw(function (endPt) {\n          // endpt in coordinate...\n          pencil.move(endPt);\n        }, function () {\n          ruler.hide();\n          pencil.hide();\n        });\n      });\n    }, 500);\n  };\n\n  return;\n  var triangle = new GEO2.Triangle(pt1, pt2, pt3, {\n    color: \"#\" + ((1 << 24) * Math.random() | 0).toString(16),\n    completeCallback: function completeCallback() {\n      var testAng = funcs.getAngleFrom3Points(triangle.vertexArr[0], triangle.vertexArr[1], triangle.vertexArr[2]);\n      var sideNumber = 3;\n      var startIndex;\n      var angles = [];\n\n      if (testAng > Math.PI) {\n        console.log(\"greater than 180\");\n        startIndex = 1;\n\n        for (var i = 0; i < sideNumber; i++) {\n          var angle = new GEO2.Angle(triangle.vertexArr[startIndex], triangle.vertexArr[(startIndex + (sideNumber - 1)) % sideNumber], triangle.vertexArr[(startIndex + (sideNumber - 1)) % sideNumber], triangle.vertexArr[(startIndex + (sideNumber - 1 - 1)) % sideNumber]);\n          startIndex = (startIndex + (sideNumber - 1)) % sideNumber;\n          angles.push(angle);\n        }\n      } else {\n        startIndex = sideNumber - 1;\n\n        for (var _i = 0; _i < sideNumber; _i++) {\n          var _angle = new GEO2.Angle(triangle.vertexArr[startIndex], triangle.vertexArr[(startIndex + 1) % sideNumber], triangle.vertexArr[(startIndex + 1) % sideNumber], triangle.vertexArr[(startIndex + 2) % sideNumber]);\n\n          startIndex = (startIndex + 1) % sideNumber;\n          angles.push(_angle);\n        }\n      }\n\n      var _loop = function _loop(_i2) {\n        angles[_i2 - 1].completeCallback = function () {\n          grid.addItem(angles[_i2]);\n        };\n      };\n\n      for (var _i2 = 1; _i2 < angles.length; _i2++) {\n        _loop(_i2);\n      }\n\n      grid.addItem(angles[0]);\n    }\n  });\n  grid.addItem(triangle);\n});\nvar btnStop2 = document.getElementById(\"btn2\");\nbtnStop2.addEventListener('click', function (evt) {\n  // protractor.moveTo({ x : 0, y : 0});\n  // protractor.rotate(Math.PI  /2 );\n  var x1 = -5 + Math.random() * 10;\n  var x2 = -5 + Math.random() * 10;\n  var y1 = -5 + Math.random() * 10;\n  var y2 = -5 + Math.random() * 10; // console.log(\"from \")\n  // console.log({ x : x1, y : y1})\n  // console.log(\"to\")\n  // console.log({x : x2, y : y2})\n  // ruler.moveTo({  x : 2.5940834948370632, y: 0.028386076934343585}, {x : 2.081371347155809, y: -3.293121912277668})\n  // ruler.moveTo({ x : 3, y : 1}, {x : -2, y : 0})\n\n  ruler.moveTo({\n    x: x1,\n    y: y1\n  }, {\n    x: x2,\n    y: y2\n  }); // protractor.hide()\n\n  return;\n});\nbtnStop2.addEventListener('click', function (evt) {\n  return; // let circle = new GEO2.Circle({ x: (Math.random() * 12) - 6, y: (Math.random() * 12) - 6 }, Math.random() * 5, { color : \"#\"+((1<<24)*Math.random()|0).toString(16)});\n  // layer1.addItem(circle);\n  // circle.updatePosCoor({ x: (Math.random() * 12) - 6, y: (Math.random() * 12) - 6 });\n  // pencil.prepareToDrawLine({ x: (Math.random() * 12) - 6, y: (Math.random() * 12) - 6 }, { x: (Math.random() * 12) - 6, y: (Math.random() * 12) - 6 });\n  // let pt1 = { x: (Math.random() * 10) - 5, y: (Math.random() * 10) - 5 };\n  // let pt2 = { x: (Math.random() * 10) - 5, y: (Math.random() * 10) - 5 };\n  // // // ruler.moveTo({ x : -9, y : 3}, { x : 2, y : -10})\n  // // ruler.moveTo(pt1, pt2);\n  // let pt3 = { x: (Math.random() * 10) - 5, y: (Math.random() * 10) - 5 };\n\n  var pt1 = {\n    x: -1.3,\n    y: -3.5\n  };\n  var pt2 = {\n    x: 2,\n    y: -1.1\n  };\n  var pt3 = {\n    x: 0.6,\n    y: 2.5\n  };\n  var triangle = new GEO2.Triangle(pt1, pt2, pt3, {\n    // color: \"#\" + ((1 << 24) * Math.random() | 0).toString(16),\n    color: \"#e811fd\",\n    completeCallback: function completeCallback() {\n      var testAng = funcs.getAngleFrom3Points(triangle.vertexArr[0], triangle.vertexArr[1], triangle.vertexArr[2]);\n      var sideNumber = 3;\n      var startIndex;\n      var angles = [];\n\n      if (testAng > Math.PI) {\n        startIndex = 1;\n\n        for (var i = 0; i < sideNumber; i++) {\n          var angle = new GEO2.Angle(triangle.vertexArr[startIndex], triangle.vertexArr[(startIndex + (sideNumber - 1)) % sideNumber], triangle.vertexArr[(startIndex + (sideNumber - 1)) % sideNumber], triangle.vertexArr[(startIndex + (sideNumber - 1 - 1)) % sideNumber]);\n          startIndex = (startIndex + (sideNumber - 1)) % sideNumber;\n          angles.push(angle);\n        }\n      } else {\n        startIndex = sideNumber - 1;\n\n        for (var _i3 = 0; _i3 < sideNumber; _i3++) {\n          var _angle2 = new GEO2.Angle(triangle.vertexArr[startIndex], triangle.vertexArr[(startIndex + 1) % sideNumber], triangle.vertexArr[(startIndex + 1) % sideNumber], triangle.vertexArr[(startIndex + 2) % sideNumber]);\n\n          startIndex = (startIndex + 1) % sideNumber;\n          angles.push(_angle2);\n        }\n      }\n\n      var _loop2 = function _loop2(_i4) {\n        angles[_i4 - 1].completeCallback = function () {\n          grid.addItem(angles[_i4]);\n        };\n      };\n\n      for (var _i4 = 1; _i4 < angles.length; _i4++) {\n        _loop2(_i4);\n      }\n\n      grid.addItem(angles[0]);\n    }\n  });\n  grid.addItem(triangle);\n});\nvar btnStop = document.getElementById(\"btnStop\");\nbtnStop.addEventListener('click', function (evt) {\n  // cancelAnimationFrame(aniId);\n  // stage.render();\n  // point.updatePosCoor({ x: Math.random() * 10\n  //     , y : Math.random() * 10\n  // });\n  // let newPoint = new GEO2.Point({ x: Math.random() * 10, y: Math.random() * 10  });\n  // layer1.addItem(newPoint);\n  stage.grid.moveAndScale({\n    x: 0,\n    y: 0\n  });\n});\nWebFont.WebFontConfig = {};\nWebFont.load({\n  custom: {\n    families: ['Computer Modern'],\n    urls: ['styles/font.css']\n  },\n  timeout: 5000,\n  active: function active() {\n    // stage.render();\n    animate();\n  }\n}); // animate();\n// testing...\n// var tests = require(\"../src/test\");\n// tests.test_getLengthOfPath();\n// let angle = funcs.getAngle({ x : -7.72, y : 0.3});\n// console.log(\"angle \" + angle);\n// let pt = funcs.getXYFromTheta(8.2, 2, 1);\n// console.log(pt);\n\n//# sourceURL=webpack://threeD/./src/app.js?");

/***/ }),

/***/ "./src/v2_geometry/GEO2.js":
/*!*********************************!*\
  !*** ./src/v2_geometry/GEO2.js ***!
  \*********************************/
/*! exports provided: Stage, Layer, Point, Circle, Triangle, Vector, Line, Angle, Ruler, Pencil, Protractor, Clock, Vector2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Stage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Stage */ \"./src/v2_geometry/Stage.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Stage\", function() { return _Stage__WEBPACK_IMPORTED_MODULE_0__[\"Stage\"]; });\n\n/* harmony import */ var _Layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Layer */ \"./src/v2_geometry/Layer.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Layer\", function() { return _Layer__WEBPACK_IMPORTED_MODULE_1__[\"Layer\"]; });\n\n/* harmony import */ var _items_Point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./items/Point */ \"./src/v2_geometry/items/Point.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Point\", function() { return _items_Point__WEBPACK_IMPORTED_MODULE_2__[\"Point\"]; });\n\n/* harmony import */ var _items_Circle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./items/Circle */ \"./src/v2_geometry/items/Circle.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Circle\", function() { return _items_Circle__WEBPACK_IMPORTED_MODULE_3__[\"Circle\"]; });\n\n/* harmony import */ var _items_Triangle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./items/Triangle */ \"./src/v2_geometry/items/Triangle.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Triangle\", function() { return _items_Triangle__WEBPACK_IMPORTED_MODULE_4__[\"Triangle\"]; });\n\n/* harmony import */ var _items_Vector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./items/Vector */ \"./src/v2_geometry/items/Vector.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Vector\", function() { return _items_Vector__WEBPACK_IMPORTED_MODULE_5__[\"Vector\"]; });\n\n/* harmony import */ var _items_Line__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./items/Line */ \"./src/v2_geometry/items/Line.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Line\", function() { return _items_Line__WEBPACK_IMPORTED_MODULE_6__[\"Line\"]; });\n\n/* harmony import */ var _items_mesurements_Angle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./items/mesurements/Angle */ \"./src/v2_geometry/items/mesurements/Angle.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Angle\", function() { return _items_mesurements_Angle__WEBPACK_IMPORTED_MODULE_7__[\"Angle\"]; });\n\n/* harmony import */ var _instruments_Ruler__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./instruments/Ruler */ \"./src/v2_geometry/instruments/Ruler.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Ruler\", function() { return _instruments_Ruler__WEBPACK_IMPORTED_MODULE_8__[\"Ruler\"]; });\n\n/* harmony import */ var _instruments_Pencil__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./instruments/Pencil */ \"./src/v2_geometry/instruments/Pencil.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Pencil\", function() { return _instruments_Pencil__WEBPACK_IMPORTED_MODULE_9__[\"Pencil\"]; });\n\n/* harmony import */ var _instruments_Protractor__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./instruments/Protractor */ \"./src/v2_geometry/instruments/Protractor.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Protractor\", function() { return _instruments_Protractor__WEBPACK_IMPORTED_MODULE_10__[\"Protractor\"]; });\n\n/* harmony import */ var _staticItems_Clock__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./staticItems/Clock */ \"./src/v2_geometry/staticItems/Clock.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Clock\", function() { return _staticItems_Clock__WEBPACK_IMPORTED_MODULE_11__[\"Clock\"]; });\n\n/* harmony import */ var _Vector2__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Vector2 */ \"./src/v2_geometry/Vector2.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Vector2\", function() { return _Vector2__WEBPACK_IMPORTED_MODULE_12__[\"Vector2\"]; });\n\n\n\n\n\n\n\n\n\n\n\n\n\n // export {Clock} from \"./utils/Clock\"\n\n//# sourceURL=webpack://threeD/./src/v2_geometry/GEO2.js?");

/***/ }),

/***/ "./src/v2_geometry/Grid.js":
/*!*********************************!*\
  !*** ./src/v2_geometry/Grid.js ***!
  \*********************************/
/*! exports provided: Grid */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Grid\", function() { return Grid; });\n/* harmony import */ var es6_tween__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! es6-tween */ \"C:\\\\Users\\\\XiaoMi\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\es6-tween\\\\bundled\\\\Tween.min.js\");\n/* harmony import */ var es6_tween__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(es6_tween__WEBPACK_IMPORTED_MODULE_0__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar TWEEN = __webpack_require__(/*! es6-tween */ \"C:\\\\Users\\\\XiaoMi\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\es6-tween\\\\bundled\\\\Tween.min.js\");\n\n\nObject(es6_tween__WEBPACK_IMPORTED_MODULE_0__[\"autoPlay\"])(true);\nvar Grid = /*#__PURE__*/function () {\n  function Grid(context, stage) {\n    _classCallCheck(this, Grid);\n\n    this.stage = stage;\n    this.context = context;\n    this.steps = [5, 2, 1];\n    this.minorAxisDivders = [5, 4, 5];\n    this.scaleBy = 1.06;\n    this.defaultCoorPerPixel = 0.025 * stage.ratio;\n    this.devicePixelRatio = stage.ratio;\n    this.drawMinorGridLines = false;\n    this.drawMajorGuidLines = false;\n    this.drawAxes = false;\n    this.colorGrid = \"#7c7c7c\";\n    this.colorText = \"#32003f\";\n    this.tickFontSize = 12;\n    this.tickFontSizeText = this.tickFontSize + 'pt Calibri';\n    this.tickLabelBackground = this.stage.canvas.style.background;\n    this.tickBackgroundHeight = this.tickFontSize + 4;\n\n    if (this.stage.canvas.width > 1000) {\n      this.initialScale = 0.01;\n    } else {\n      this.initialScale = 0.02;\n    }\n\n    var right = this.stage.canvasWidth * this.defaultCoorPerPixel / 2;\n    var top = this.stage.canvasHeight * this.defaultCoorPerPixel / 2;\n    this.updatingScaleOrRange = false;\n    this.tick_pos_px = {};\n    this.ptOriginPx = {};\n    this.points = [];\n    this.lines = [];\n    this.segments = [];\n    this.circles = [];\n    this.rectangles = [];\n    this.triangles = [];\n    this.angles = [];\n    this.vectors = [];\n    this.lines = [];\n    this.instruments = [];\n    this.groupPoints = new RenderOrderGroup();\n    this.groupLines = new RenderOrderGroup();\n    this.groupShapes = new RenderOrderGroup();\n    this.updateBoundaryCoordinateLRTB(-right, right, top, -top);\n  }\n\n  _createClass(Grid, [{\n    key: \"addItem\",\n    value: function addItem(item) {\n      item.setContext(this.context, this);\n\n      if (item.type === \"Point\") {\n        this.points.push(item);\n        this.groupPoints.add(item);\n      } else if (item.type == \"Angle\") {\n        this.angles.push(item);\n        this.groupPoints.add(item);\n      } else if (item.type === \"Circle\") {\n        this.circles.push(item);\n        this.groupShapes.add(item);\n      } else if (item.type === \"Triangle\") {\n        this.triangles.push(item);\n        this.groupShapes.add(item);\n      } else if (item.type == \"Ruler\" || item.type == \"Pencil\" || item.type == \"Protractor\") {\n        this.instruments.push(item);\n      } else if (item.type == \"Vector\") {\n        this.vectors.push(item);\n        this.groupLines.add(item);\n      } else if (item.type == \"Line\") {\n        this.lines.push(item);\n        this.groupLines.add(item);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this = this;\n\n      this.go = true;\n      this.n = 1;\n\n      while (this.go) {\n        this.possibleSteps = this.steps.map(function (x) {\n          return x * Math.pow(10, _this.widthCoor.toFixed(0).length - _this.n);\n        });\n        this.n++;\n\n        for (var i = 0; i < this.possibleSteps.length; i++) {\n          this.pixel_per_step = this.stage.canvasWidth / (this.widthCoor / this.possibleSteps[i]);\n\n          if (this.pixel_per_step < 170) {\n            this.left_to_start = Math.ceil(this.left / this.possibleSteps[i]) * this.possibleSteps[i];\n            this.bottom_to_start = Math.ceil(this.bottom / this.possibleSteps[i]) * this.possibleSteps[i];\n            this.step = this.possibleSteps[i];\n            this.minorGridDivider = this.minorAxisDivders[i];\n            this.stepPx = parseInt(this.step / this.coorPerPixel / this.minorGridDivider);\n            this.go = false;\n            break;\n          }\n        }\n      } // start drawing..\n\n\n      this.context.beginPath();\n      this.context.strokeStyle = this.colorGrid;\n      this.context.lineWidth = 1;\n      this.context.font = this.tickFontSizeText;\n      this.context.textAlign = \"center\";\n      this.context.textBaseline = 'bottom';\n      this.context.mozImageSmoothingEnabled = false; // margins, padding and offsets\n\n      this.yTickOffsetRight = 4;\n      this.no_of_ticks_x = (this.right - this.left_to_start) / this.step;\n      this.no_of_ticks_y = (this.top - this.bottom_to_start) / this.step;\n\n      if (this.drawMajorGuidLines) {\n        for (var _i = 0; _i < this.no_of_ticks_x; _i++) {\n          this.tick_value = parseFloat((this.left_to_start + _i * this.step).toFixed(10));\n          this.getPixFromCoorFT(this.tick_value, 0, this.tick_pos_px);\n\n          if (this.tick_value == 0) {\n            continue;\n          }\n\n          this.context.moveTo(this.tick_pos_px.x, this.stage.canvasHeight);\n          this.context.lineTo(this.tick_pos_px.x, 0);\n        }\n\n        for (var _i2 = 0; _i2 < this.no_of_ticks_y; _i2++) {\n          this.pt_for_lb = (this.bottom_to_start + _i2 * this.step).toFixed(10);\n          this.tick_value = parseFloat(this.pt_for_lb);\n          this.getPixFromCoorFT(0, this.tick_value, this.tick_pos_px);\n\n          if (this.tick_value == 0) {\n            continue;\n          }\n\n          this.context.moveTo(0, this.tick_pos_px.y);\n          this.context.lineTo(this.stage.canvasWidth, this.tick_pos_px.y);\n        }\n      }\n\n      this.context.stroke(); // draw x-axis\n\n      if (this.drawAxes) {\n        this.getPixFromCoorFT(0, 0, this.ptOriginPx);\n        this.context.beginPath();\n        this.context.strokeStyle = \"#000000\";\n        this.context.moveTo(0, this.ptOriginPx.y);\n        this.context.lineTo(this.stage.canvasWidth, this.ptOriginPx.y);\n        this.context.moveTo(this.ptOriginPx.x, 0);\n        this.context.lineTo(this.ptOriginPx.x, this.stage.canvasHeight);\n        this.context.stroke();\n        this.context.lineWidth = 2;\n        this.context.strokeStyle = \"#999999\";\n\n        for (var _i3 = -1; _i3 < this.no_of_ticks_x; _i3++) {\n          this.tick_value = parseFloat((this.left_to_start + _i3 * this.step).toFixed(10));\n          this.getPixFromCoorFT(this.tick_value, 0, this.tick_pos_px);\n          this.widthXLabel = this.context.measureText(this.tick_value).width;\n\n          if (this.tick_value == 0) {\n            this.context.textAlign = \"right\";\n            this.context.fillStyle = this.colorText;\n            this.context.fillText(this.tick_value, this.tick_pos_px.x - this.yTickOffsetRight, this.tick_pos_px.y + this.tickBackgroundHeight);\n            this.context.textAlign = \"center\";\n          } else if (_i3 != -1) {\n            this.context.fillStyle = this.stage.bgColor;\n            this.context.fillRect(this.tick_pos_px.x - 2 - this.widthXLabel / 2, this.tick_pos_px.y + 3, this.widthXLabel + 4, this.tickBackgroundHeight);\n            this.context.fillStyle = this.colorText;\n            this.context.fillText(this.tick_value, this.tick_pos_px.x, this.tick_pos_px.y + this.tickBackgroundHeight);\n          }\n\n          if (this.drawMinorGridLines) {\n            for (var j = 1; j < this.minorGridDivider; j++) {\n              this.context.moveTo(this.tick_pos_px.x + this.stepPx * j, this.stage.canvasHeight);\n              this.context.lineTo(this.tick_pos_px.x + this.stepPx * j, 0);\n            }\n          }\n        }\n\n        this.context.textAlign = \"right\";\n\n        for (var _i4 = -1; _i4 < this.no_of_ticks_y; _i4++) {\n          this.tick_value = parseFloat((this.bottom_to_start + _i4 * this.step).toFixed(10));\n          this.getPixFromCoorFT(0, this.tick_value, this.tick_pos_px);\n\n          if (this.tick_value != 0 && _i4 != -1) {\n            this.labelWidth = this.context.measureText(this.tick_value).width + 2;\n            this.context.fillStyle = this.stage.bgColor;\n            this.context.fillRect(this.tick_pos_px.x - this.labelWidth - this.yTickOffsetRight, this.tick_pos_px.y - this.tickFontSize / 2, this.labelWidth, this.tickFontSize);\n            this.context.fillStyle = this.colorText;\n            this.context.fillText(this.tick_value, this.tick_pos_px.x - this.yTickOffsetRight, this.tick_pos_px.y + this.tickFontSize / 2);\n          }\n\n          if (this.drawMinorGridLines) {\n            for (var _j = 1; _j < this.minorGridDivider; _j++) {\n              this.context.moveTo(0, this.tick_pos_px.y - this.stepPx * _j);\n              this.context.lineTo(this.stage.canvasWidth, this.tick_pos_px.y - this.stepPx * _j);\n            }\n          }\n        }\n\n        this.context.stroke();\n      } //  render items...\n\n\n      this.groupShapes.render();\n      this.groupLines.render();\n      this.groupPoints.render();\n      this.instruments.forEach(function (instrument) {\n        instrument.render();\n      });\n    }\n  }, {\n    key: \"tapHanlder\",\n    value: function tapHanlder(ptPx) {\n      var i;\n      this.itemTapped = false;\n\n      for (i = 0; i < this.groupPoints.items.length; i++) {\n        if (this.groupPoints.items[i].checkSelection(ptPx) && !this.itemTapped) {\n          this.groupPoints.items[i].handleTap(true);\n          this.itemTapped = true;\n        } else {\n          this.groupPoints.items[i].handleTap(false);\n        }\n      }\n\n      for (i = 0; i < this.groupShapes.items.length; i++) {\n        if (this.groupShapes.items[i].checkSelection(ptPx) && !this.itemTapped) {\n          this.groupShapes.items[i].handleTap(true);\n          this.itemTapped = true;\n        } else {\n          this.groupShapes.items[i].handleTap(false);\n        }\n      }\n    }\n  }, {\n    key: \"wheelHandler\",\n    value: function wheelHandler(ptPx, factor) {\n      this.updatingScaleOrRange = true;\n      this.mouseLocCoor = this.getCoorFromPixPt(ptPx);\n      this.updateBoundaryCoordinateLRTB(this.mouseLocCoor.x - (this.mouseLocCoor.x - this.left) * factor, this.mouseLocCoor.x - (this.mouseLocCoor.x - this.right) * factor, this.mouseLocCoor.y - (this.mouseLocCoor.y - this.top) * factor, this.mouseLocCoor.y - (this.mouseLocCoor.y - this.bottom) * factor); // update scale of measurements items\n\n      this.updatingScaleOrRange = false;\n    }\n  }, {\n    key: \"pinchStartHandler\",\n    value: function pinchStartHandler(ptPx) {\n      this.pinchLastPointPx = ptPx;\n      this.last_scale = 1;\n      this.updatingScaleOrRange = true;\n    }\n  }, {\n    key: \"pinchHandler\",\n    value: function pinchHandler(ptPx, scale) {\n      this.scale = this.last_scale / scale;\n      this.mouse_loc_coor = this.getCoorFromPixPt(ptPx);\n      this.last_mouse_loc_coor = this.getCoorFromPixPt(this.pinchLastPointPx);\n      this.updateBoundaryCoordinateLRTB(this.mouse_loc_coor.x - (this.mouse_loc_coor.x - this.left) * this.scale - (this.mouse_loc_coor.x - this.last_mouse_loc_coor.x), this.mouse_loc_coor.x + (this.right - this.mouse_loc_coor.x) * this.scale - (this.mouse_loc_coor.x - this.last_mouse_loc_coor.x), this.mouse_loc_coor.y + (this.top - this.mouse_loc_coor.y) * this.scale - (this.mouse_loc_coor.y - this.last_mouse_loc_coor.y), this.mouse_loc_coor.y - (this.mouse_loc_coor.y - this.bottom) * this.scale - (this.mouse_loc_coor.y - this.last_mouse_loc_coor.y));\n      this.last_scale = scale;\n      this.pinchLastPointPx = ptPx;\n    } // must implement if all grid types..\n\n  }, {\n    key: \"pinchEndHandler\",\n    value: function pinchEndHandler(ptPx) {\n      this.updatingScaleOrRange = false;\n    } // must implement if all grid types..\n\n  }, {\n    key: \"pinchCancelHandler\",\n    value: function pinchCancelHandler(ptPx) {\n      this.updatingScaleOrRange = false;\n    } // must implement if all grid types..\n\n  }, {\n    key: \"panStartHandler\",\n    value: function panStartHandler(ptPx) {\n      var i, item; // for(i = 0; i < this.groupPoints.items.length; i++){\n      //     item = this.groupPoints.items[i];\n      //     if(item.pannable && item.checkSelection(ptPx)){\n      //         return;\n      //     }\n      // }\n\n      for (i = 0; i < this.groupShapes.items.length; i++) {\n        item = this.groupPoints.items[i];\n\n        if (item.pannable && item.checkSelection(ptPx)) {\n          item.handlePanStart(ptPx);\n          this.pannedItem = item;\n          return true;\n        }\n      }\n\n      for (i = 0; i < this.instruments.length; i++) {\n        item = this.instruments[i];\n\n        if (item.pannable && item.checkSelection(ptPx)) {\n          item.handlePanStart(ptPx);\n          this.pannedItem = item;\n          return true;\n        }\n      }\n\n      this.panStartPointPx = ptPx;\n      this.updatingScaleOrRange = true;\n    } // must implement if all grid types..\n\n  }, {\n    key: \"panMoveHandler\",\n    value: function panMoveHandler(ptPx) {\n      if (this.pannedItem) {\n        this.pannedItem.handlePanMove(ptPx);\n      } else {\n        var deltaXCoor = (ptPx.x - this.panStartPointPx.x) * this.coorPerPixel;\n        var deltaYCoor = (ptPx.y - this.panStartPointPx.y) * this.coorPerPixel;\n        this.updateBoundaryCoordinateDelta(deltaXCoor, deltaYCoor);\n        this.panStartPointPx = ptPx;\n      }\n    }\n  }, {\n    key: \"panEndHandler\",\n    value: function panEndHandler(ptPx) {\n      if (this.pannedItem) {\n        this.pannedItem.handlePanEnd(ptPx);\n        this.pannedItem = undefined;\n      } else {\n        this.updatingScaleOrRange = false;\n        this.pannedItem = undefined;\n      }\n    }\n  }, {\n    key: \"moveAndScale\",\n    value: function moveAndScale(newCenter, newCoorPerPixel) {\n      var _this2 = this;\n\n      this.oldCenter = {\n        x: (this.right + this.left) / 2,\n        y: (this.top + this.bottom) / 2,\n        coorPerPixel: this.coorPerPixel\n      };\n      var target;\n\n      if (!newCoorPerPixel) {\n        target = {\n          x: newCenter.x,\n          y: newCenter.y,\n          coorPerPixel: this.defaultCoorPerPixel\n        };\n      }\n\n      var halfWidthPixel = this.stage.canvasWidth / 2;\n      var halfHeightPixel = this.stage.canvasHeight / 2;\n      var tween = new es6_tween__WEBPACK_IMPORTED_MODULE_0__[\"Tween\"](this.oldCenter).to(target, 500).easing(es6_tween__WEBPACK_IMPORTED_MODULE_0__[\"Easing\"].Quadratic.InOut).on('update', function (currentValue) {\n        _this2.updateBoundaryCoordinateLRTB(currentValue.x - halfWidthPixel * currentValue.coorPerPixel, currentValue.x + halfWidthPixel * currentValue.coorPerPixel, currentValue.y + halfHeightPixel * currentValue.coorPerPixel, currentValue.y - halfHeightPixel * currentValue.coorPerPixel);\n\n        _this2.adjustMesurementScales();\n\n        if (_this2.updatingScaleOrRange) {\n          TWEEN.remove(tween);\n        }\n      }).start();\n    } // fixToAllItems(){\n    //     for(let i = 0; i < this.linkedLayers.length; i++){\n    //     }\n    // }\n\n  }, {\n    key: \"updateBoundaryCoordinateLRTB\",\n    value: function updateBoundaryCoordinateLRTB(left, right, top, bottom) {\n      this.left = left;\n      this.right = right;\n      this.widthCoor = right - left;\n      this.top = top;\n      this.bottom = bottom;\n      this.heightCoor = top - bottom;\n      this.coorPerPixel = this.widthCoor / this.stage.canvasWidth;\n      this.adjustMesurementScales();\n      this.updatePixelLocation();\n    }\n  }, {\n    key: \"updateBoundaryCoordinate\",\n    value: function updateBoundaryCoordinate(left, width, top, height) {\n      this.left = left;\n      this.right = left + width;\n      this.widthCoor = width;\n      this.top = top;\n      this.bottom = top - height;\n      this.heightCoor = height;\n      this.coorPerPixel = width / this.stage.canvasWidth;\n      this.updatePixelLocation();\n    }\n  }, {\n    key: \"updateBoundaryCoordinateDelta\",\n    value: function updateBoundaryCoordinateDelta(deltaXCoor, deltaYCoor) {\n      this.left -= deltaXCoor;\n      this.right = this.left + this.widthCoor;\n      this.top += deltaYCoor;\n      this.bottom = this.top - this.heightCoor;\n      this.updatePixelLocation();\n    } // getPixFromCoorPt(pt) {\n    //     return { x: Math.round(this.stage.canvasWidth * (pt.x - this.left) / this.widthCoor) + .5, y: Math.round(this.stage.canvasHeight - (this.stage.canvasHeight * (pt.y - this.bottom) / this.heightCoor)) + .5 }\n    // }\n\n  }, {\n    key: \"getPixFromCoorPt\",\n    value: function getPixFromCoorPt(pt) {\n      return {\n        x: this.stage.canvasWidth * (pt.x - this.left) / this.widthCoor,\n        y: this.stage.canvasHeight - this.stage.canvasHeight * (pt.y - this.bottom) / this.heightCoor\n      };\n    }\n  }, {\n    key: \"getPixFromCoorPtFT\",\n    value: function getPixFromCoorPtFT(pt, toPt) {\n      toPt.x = this.stage.canvasWidth * (pt.x - this.left) / this.widthCoor;\n      toPt.y = this.stage.canvasHeight - this.stage.canvasHeight * (pt.y - this.bottom) / this.heightCoor;\n    } // FT means \"from\", \"to\"\n    // OF means \"with offset\"\n\n  }, {\n    key: \"getPixFromCoorPtFTwOF\",\n    value: function getPixFromCoorPtFTwOF(pt, toPt, offset) {\n      toPt.x = offset.x + this.stage.canvasWidth * (pt.x - this.left) / this.widthCoor;\n      toPt.y = offset.y + this.stage.canvasHeight - this.stage.canvasHeight * (pt.y - this.bottom) / this.heightCoor;\n    } // getPixFromCoorPtRounded(pt) {\n    //     return { x: Math.round(this.stage.canvasWidth * (pt.x - this.left) / this.widthCoor) + .5, y: Math.round(this.stage.canvasHeight - (this.stage.canvasHeight * (pt.y - this.bottom) / this.heightCoor)) + .5 }\n    // }\n\n  }, {\n    key: \"getPixFromCoorPtRounded\",\n    value: function getPixFromCoorPtRounded(pt) {\n      return {\n        x: this.stage.canvasWidth * (pt.x - this.left) / this.widthCoor,\n        y: this.stage.canvasHeight - this.stage.canvasHeight * (pt.y - this.bottom) / this.heightCoor\n      };\n    } // getPixFromCoor(x, y) {\n    //     return { x: Math.round(this.stage.canvasWidth * (x - this.left) / this.widthCoor) + .5, y: Math.round(this.stage.canvasHeight - (this.stage.canvasHeight * (y - this.bottom) / this.heightCoor)) + .5 }\n    // }\n\n  }, {\n    key: \"getPixFromCoor\",\n    value: function getPixFromCoor(x, y) {\n      return {\n        x: this.stage.canvasWidth * (x - this.left) / this.widthCoor,\n        y: this.stage.canvasHeight - this.stage.canvasHeight * (y - this.bottom) / this.heightCoor\n      };\n    }\n  }, {\n    key: \"getPixFromCoorFT\",\n    value: function getPixFromCoorFT(x, y, toPt) {\n      toPt.x = this.stage.canvasWidth * (x - this.left) / this.widthCoor;\n      toPt.y = this.stage.canvasHeight - this.stage.canvasHeight * (y - this.bottom) / this.heightCoor;\n    } // getPixFromCoorRounded(x, y) {\n    //     return { x: Math.round(this.stage.canvasWidth * (x - this.left) / this.widthCoor) + .5, y: Math.round(this.stage.canvasHeight - (this.stage.canvasHeight * (y - this.bottom) / this.heightCoor)) + .5 }\n    // }\n\n  }, {\n    key: \"getPixFromCoorRounded\",\n    value: function getPixFromCoorRounded(x, y) {\n      return {\n        x: this.stage.canvasWidth * (x - this.left) / this.widthCoor,\n        y: this.stage.canvasHeight - this.stage.canvasHeight * (y - this.bottom) / this.heightCoor\n      };\n    } // getCoorFromPixPt(pt) {\n    //     return { x: this.left + (this.widthCoor * (pt.x / this.stage.canvasWidth)), y: this.bottom + (this.heightCoor * ((this.stage.canvasHeight - pt.y) / this.stage.canvasHeight)) }\n    // }\n\n  }, {\n    key: \"getCoorFromPixPt\",\n    value: function getCoorFromPixPt(pt) {\n      return {\n        x: this.left + this.widthCoor * (pt.x / this.stage.canvasWidth),\n        y: this.bottom + this.heightCoor * ((this.stage.canvasHeight - pt.y) / this.stage.canvasHeight)\n      };\n    }\n  }, {\n    key: \"getCoorFromPixFT\",\n    value: function getCoorFromPixFT(x, y, toPt) {\n      toPt.x = this.left + this.widthCoor * (x / this.stage.canvasWidth);\n      toPt.y = this.bottom + this.heightCoor * ((this.stage.canvasHeight - y) / this.stage.canvasHeight);\n    }\n  }, {\n    key: \"getCoorFromPix\",\n    value: function getCoorFromPix(x, y) {\n      return {\n        x: this.left + this.widthCoor * (x / this.stage.canvasWidth),\n        y: this.bottom + this.heightCoor * ((this.stage.canvasHeight - y) / this.stage.canvasHeight)\n      };\n    }\n  }, {\n    key: \"updatePixelLocation\",\n    value: function updatePixelLocation() {\n      this.groupPoints.items.forEach(function (item) {\n        item.updatePixelLocation();\n      });\n      this.groupShapes.items.forEach(function (item) {\n        item.updatePixelLocation();\n      });\n      this.groupLines.items.forEach(function (item) {\n        item.updatePixelLocation();\n      });\n      this.instruments.forEach(function (instrument) {\n        instrument.updatePixelLocation();\n      });\n    }\n  }, {\n    key: \"adjustMesurementScales\",\n    value: function adjustMesurementScales() {\n      this.angles.forEach(function (angle) {\n        angle.adjustScale();\n      });\n      this.instruments.forEach(function (instrument) {\n        instrument.adjustScale();\n      });\n    }\n  }]);\n\n  return Grid;\n}();\n\nvar RenderOrderGroup = /*#__PURE__*/function () {\n  function RenderOrderGroup() {\n    _classCallCheck(this, RenderOrderGroup);\n\n    this.items = [];\n  }\n\n  _createClass(RenderOrderGroup, [{\n    key: \"add\",\n    value: function add(item) {\n      this.items.push(item);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.items.forEach(function (item) {\n        item.render();\n      });\n    }\n  }]);\n\n  return RenderOrderGroup;\n}();\n\n//# sourceURL=webpack://threeD/./src/v2_geometry/Grid.js?");

/***/ }),

/***/ "./src/v2_geometry/Layer.js":
/*!**********************************!*\
  !*** ./src/v2_geometry/Layer.js ***!
  \**********************************/
/*! exports provided: Layer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Layer\", function() { return Layer; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Layer = /*#__PURE__*/function () {\n  function Layer(config) {\n    _classCallCheck(this, Layer);\n\n    this.smallItems = [];\n    this.largeItems = [];\n    this.widthCoor = 200;\n\n    for (var objName in config) {\n      if (this[objName] == undefined) {\n        console.warn(Layer.name + \": \" + objName + \" parameter is undefined.\");\n      }\n\n      this[objName] = config[objName];\n    }\n  }\n\n  _createClass(Layer, [{\n    key: \"setContext\",\n    value: function setContext(context, stage) {\n      if (!this.context) {\n        // set context to all items..\n        this.smallItems.forEach(function (item) {\n          item.setContext(context, container);\n        });\n        this.largeItems.forEach(function (item) {\n          item.setContext(context, container);\n        });\n      }\n\n      this.context = context;\n      this.stage = stage;\n      this.heightCoor = stage.canvasHeight / stage.canvasWidth * this.widthCoor;\n      this.coorPerPixel = this.widthCoor / stage.canvasWidth;\n    }\n  }, {\n    key: \"addItem\",\n    value: function addItem(item) {\n      if (item.itemSize === \"Small\") {\n        this.smallItems.push(item);\n      } else if (item.itemSize === \"Large\") {\n        this.largeItems.push(item);\n      }\n\n      item.setContext(this.context, this);\n    }\n  }, {\n    key: \"removeItem\",\n    value: function removeItem() {// remove item from item list\n      // remove item from render order group\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.smallItems.forEach(function (item) {\n        item.render();\n      });\n      this.largeItems.forEach(function (item) {\n        item.render();\n      });\n    }\n  }, {\n    key: \"getPixFromCoorPt\",\n    value: function getPixFromCoorPt(pt) {\n      return {\n        x: Math.round(pt.x / this.coorPerPixel) + .5,\n        y: Math.round(this.stage.canvasHeight - pt.y / this.coorPerPixel) + .5\n      };\n    }\n  }]);\n\n  return Layer;\n}();\n\n//# sourceURL=webpack://threeD/./src/v2_geometry/Layer.js?");

/***/ }),

/***/ "./src/v2_geometry/Stage.js":
/*!**********************************!*\
  !*** ./src/v2_geometry/Stage.js ***!
  \**********************************/
/*! exports provided: Stage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Stage\", function() { return Stage; });\n/* harmony import */ var _Grid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Grid */ \"./src/v2_geometry/Grid.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n__webpack_require__(/*! hammerjs */ \"C:\\\\Users\\\\XiaoMi\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\hammerjs\\\\hammer.js\");\n\nvar Stage = /*#__PURE__*/function () {\n  function Stage(container) {\n    var _this = this;\n\n    _classCallCheck(this, Stage);\n\n    this.bgColor = \"#ffffff\";\n    this.containerElement = document.getElementById(container);\n    this.positionInfo = this.containerElement.getBoundingClientRect(); // this.positionInfo.width = Math.floor(this.positionInfo.width);\n    // this.positionInfo.height = Math.floor(this.positionInfo.height);\n\n    this.canvas = document.createElement(\"canvas\");\n    this.canvas.style.position = \"absolute\";\n    this.canvas.style.width = this.positionInfo.width + \"px\";\n    this.canvas.style.height = this.positionInfo.height + \"px\";\n    this.canvas.style.background = this.bgColor;\n    this.containerElement.appendChild(this.canvas);\n    this.context = this.canvas.getContext(\"2d\", {\n      alpha: false\n    });\n    this.context.imageSmoothingEnabled = false;\n    this.makeHighResolution(); // update this vairables whenever canvas size is updated..\n\n    this.canvasWidth = this.positionInfo.width;\n    this.canvasHeight = this.positionInfo.height; // this.canvasWidth = this.canvas.width;\n    // this.canvasHeight = this.canvas.height;\n\n    this.hammer = new Hammer(this.canvas, {\n      domEvents: true\n    });\n    this.hammer.get('pan').set({\n      direction: Hammer.DIRECTION_ALL,\n      threshold: 0\n    });\n    this.hammer.get('pinch').set({\n      enable: true,\n      threshold: 0\n    }); // this.hammer.get('tap').set({ time : 10});\n\n    this.hammer.on(\"panstart\", function (e) {\n      return _this.panStartHandler(e);\n    });\n    this.hammer.on(\"panmove\", function (e) {\n      return _this.panMoveHandler(e);\n    });\n    this.hammer.on(\"panend\", function (e) {\n      return _this.panEndHandler(e);\n    });\n    this.hammer.on(\"pinchstart\", function (e) {\n      return _this.pinchStartHandler(e);\n    });\n    this.hammer.on(\"pinch\", function (e) {\n      return _this.pinchHandler(e);\n    });\n    this.hammer.on(\"pinchend\", function (e) {\n      return _this.pinchEndHandler(e);\n    });\n    this.hammer.on(\"pinchcancel\", function (e) {\n      return _this.pinchCancelHandler(e);\n    });\n    this.hammer.on(\"tap\", function (e) {\n      return _this.tapHandler(e);\n    });\n    this.canvas.addEventListener(\"wheel\", function (e) {\n      return _this.wheelHandler(e);\n    });\n    this.layers = []; // dyanmic layers\n\n    this.grid = undefined; // some unitilty tools.\n\n    this.console = document.getElementById(\"console\");\n  }\n\n  _createClass(Stage, [{\n    key: \"getGrid\",\n    value: function getGrid() {\n      if (!this.grid) {\n        this.grid = new _Grid__WEBPACK_IMPORTED_MODULE_0__[\"Grid\"](this.context, this);\n        this.grid.devicePixelRatio = this.ratio;\n      }\n\n      return this.grid;\n    }\n  }, {\n    key: \"tapHandler\",\n    value: function tapHandler(event) {\n      this.currentCanvasPos = this.canvas.getBoundingClientRect();\n      this.currentPos = {\n        x: event.center.x - this.currentCanvasPos.left,\n        y: event.center.y - this.currentCanvasPos.top\n      }; // search items in uppper layers...\n      // if no item is found, then search in grid\n\n      this.grid.tapHanlder(this.currentPos);\n    }\n  }, {\n    key: \"pinchStartHandler\",\n    value: function pinchStartHandler(event) {\n      this.currentCanvasPos = this.canvas.getBoundingClientRect();\n      this.currentPos = {\n        x: event.center.x - this.currentCanvasPos.left,\n        y: event.center.y - this.currentCanvasPos.top\n      };\n\n      if (this.grid) {\n        this.grid.pinchStartHandler(this.currentPos);\n      }\n    }\n  }, {\n    key: \"pinchHandler\",\n    value: function pinchHandler(event) {\n      this.currentCanvasPos = this.canvas.getBoundingClientRect();\n      this.currentPos = {\n        x: event.center.x - this.currentCanvasPos.left,\n        y: event.center.y - this.currentCanvasPos.top\n      };\n\n      if (this.grid) {\n        this.grid.pinchHandler(this.currentPos, event.scale);\n      }\n    }\n  }, {\n    key: \"pinchEndHandler\",\n    value: function pinchEndHandler(event) {\n      this.currentCanvasPos = this.canvas.getBoundingClientRect();\n      this.currentPos = {\n        x: event.center.x - this.currentCanvasPos.left,\n        y: event.center.y - this.currentCanvasPos.top\n      };\n\n      if (this.grid) {\n        this.grid.pinchEndHandler(this.currentPos);\n      }\n    }\n  }, {\n    key: \"pinchCancelHandler\",\n    value: function pinchCancelHandler(event) {\n      this.currentCanvasPos = this.canvas.getBoundingClientRect();\n      this.currentPos = {\n        x: event.center.x - this.currentCanvasPos.left,\n        y: event.center.y - this.currentCanvasPos.top\n      };\n\n      if (this.grid) {\n        this.grid.pinchCancelHandler(this.currentPos);\n      }\n    }\n  }, {\n    key: \"panStartHandler\",\n    value: function panStartHandler(event) {\n      this.currentCanvasPos = this.canvas.getBoundingClientRect();\n      this.currentPos = {\n        x: event.center.x - this.currentCanvasPos.left,\n        y: event.center.y - this.currentCanvasPos.top\n      }; // searth selected items...\n      // if there is no item to select, then drag the grid...\n\n      if (this.grid) {\n        this.grid.panStartHandler(this.currentPos);\n      }\n    }\n  }, {\n    key: \"panMoveHandler\",\n    value: function panMoveHandler(event) {\n      this.currentCanvasPos = this.canvas.getBoundingClientRect();\n      this.currentPos = {\n        x: event.center.x - this.currentCanvasPos.left,\n        y: event.center.y - this.currentCanvasPos.top\n      };\n\n      if (this.grid) {\n        this.grid.panMoveHandler(this.currentPos);\n      }\n    }\n  }, {\n    key: \"panEndHandler\",\n    value: function panEndHandler(event) {\n      this.currentCanvasPos = this.canvas.getBoundingClientRect();\n      this.currentPos = {\n        x: event.center.x - this.currentCanvasPos.left,\n        y: event.center.y - this.currentCanvasPos.top\n      };\n\n      if (this.grid) {\n        this.grid.panEndHandler(this.currentPos);\n      }\n    }\n  }, {\n    key: \"wheelHandler\",\n    value: function wheelHandler(event) {\n      if (this.grid) {\n        this.grid.wheelHandler({\n          x: event.layerX,\n          y: event.layerY\n        }, Math.pow(this.grid.scaleBy, Math.sign(event.deltaY)));\n      }\n    }\n  }, {\n    key: \"addLayer\",\n    value: function addLayer(layer) {\n      this.layers.push(layer);\n      layer.setContext(this.context, this);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.context.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n      this.context.fillStyle = this.bgColor;\n      this.context.fillRect(0, 0, this.canvasWidth, this.canvasHeight);\n\n      if (this.grid) {\n        this.grid.render();\n      }\n    }\n  }, {\n    key: \"makeHighResolution\",\n    value: function makeHighResolution() {\n      this.devicePixelRatio = window.devicePixelRatio || 1;\n      var backingStoreRatio = this.context.webkitBackingStorePixelRatio || this.context.mozBackingStorePixelRatio || this.context.msBackingStorePixelRatio || this.context.oBackingStorePixelRatio || this.context.backingStorePixelRatio || 1;\n      this.ratio = this.devicePixelRatio / backingStoreRatio;\n\n      if (this.devicePixelRatio !== backingStoreRatio) {\n        var oldWidth = this.positionInfo.width;\n        var oldHeight = this.positionInfo.height;\n        this.canvas.width = Math.round(oldWidth * this.ratio);\n        this.canvas.height = Math.round(oldHeight * this.ratio); // this.canvas.style.width = oldWidth + 'px';\n        // this.canvas.style.height = oldHeight + 'px';\n        // this.context.scale(1, 1);\n        // this.context.scale(parseFloat(this.ratio.toPrecision(3)), parseFloat(this.ratio.toPrecision(3)));\n\n        this.context.scale(this.ratio, this.ratio); // this.context.scale(.9, .9);\n      } // alert(this.devicePixelRatio)\n\n    }\n  }, {\n    key: \"writeToConsole\",\n    value: function writeToConsole(msg) {\n      this.console.innerHTML += \"<p>\" + msg + \"</p>\";\n      this.console.scrollTop = this.console.scrollHeight;\n    }\n  }]);\n\n  return Stage;\n}();\n\n//# sourceURL=webpack://threeD/./src/v2_geometry/Stage.js?");

/***/ }),

/***/ "./src/v2_geometry/Vector2.js":
/*!************************************!*\
  !*** ./src/v2_geometry/Vector2.js ***!
  \************************************/
/*! exports provided: Vector2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vector2\", function() { return Vector2; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Vector2 = /*#__PURE__*/function () {\n  function Vector2() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, Vector2);\n\n    this.x = x;\n    this.y = y;\n  }\n\n  _createClass(Vector2, [{\n    key: \"set\",\n    value: function set(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Vector2(this.x, this.y);\n    }\n  }, {\n    key: \"copyFrom\",\n    value: function copyFrom(sourceVect) {\n      this.x = sourceVect.x;\n      this.y = sourceVect.y;\n    }\n  }, {\n    key: \"subtractFrom\",\n    value: function subtractFrom(vect) {\n      return new Vector2(vect.x - this.x, vect.y - this.y);\n    }\n  }, {\n    key: \"copyTo\",\n    value: function copyTo(distVect) {}\n  }]);\n\n  return Vector2;\n}();\n\n//# sourceURL=webpack://threeD/./src/v2_geometry/Vector2.js?");

/***/ }),

/***/ "./src/v2_geometry/instruments/Pencil.js":
/*!***********************************************!*\
  !*** ./src/v2_geometry/instruments/Pencil.js ***!
  \***********************************************/
/*! exports provided: Pencil */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Pencil\", function() { return Pencil; });\n/* harmony import */ var _items_Vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../items/Vector */ \"./src/v2_geometry/items/Vector.js\");\n/* harmony import */ var es6_tween__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! es6-tween */ \"C:\\\\Users\\\\XiaoMi\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\es6-tween\\\\bundled\\\\Tween.min.js\");\n/* harmony import */ var es6_tween__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(es6_tween__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/constants */ \"./src/v2_geometry/utils/constants.js\");\n/* harmony import */ var _utils_constants__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_utils_constants__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Vector2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Vector2 */ \"./src/v2_geometry/Vector2.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar funcs = __webpack_require__(/*! ../utils/funcs */ \"./src/v2_geometry/utils/funcs.js\");\n\n\n\nvar TWEEN = __webpack_require__(/*! es6-tween */ \"C:\\\\Users\\\\XiaoMi\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\es6-tween\\\\bundled\\\\Tween.min.js\");\n\n\n\n\nObject(es6_tween__WEBPACK_IMPORTED_MODULE_1__[\"autoPlay\"])(true);\nvar Pencil = /*#__PURE__*/function () {\n  function Pencil(config) {\n    _classCallCheck(this, Pencil);\n\n    this.color = \"#5b79ff\";\n    this.halfWidth = .29; // 7 mm\n\n    this.length = 11;\n    this.headLength = 1.1;\n    this.tipLength = .29;\n    this.tipBaseHalfWidth = .07;\n    this.eraserHeight = .4;\n\n    for (var objName in config) {\n      if (this[objName] == undefined) {\n        console.warn(Pencil.name + \": \" + objName + \" parameter is undefined.\");\n      }\n\n      this[objName] = config[objName];\n    }\n\n    this.colorRGB = funcs.hexToRgb(this.color);\n    this.colorRGBa = \"rgba(\" + this.colorRGB[0] + \", \" + this.colorRGB[1] + \", \" + this.colorRGB[2] + \", \" + 1 + \")\";\n    this.pos = {\n      x: 0,\n      y: 0\n    };\n    this.posPx = {};\n    this.globalAlpha = 1;\n    this.pencilInclinationAngle = Math.PI / 3;\n    this.type = \"Pencil\";\n    this.neckLeftPx = {\n      x: 0,\n      y: 0\n    };\n    this.neckRightPx = {\n      x: 0,\n      y: 0\n    };\n    this.endLeftPx = {\n      x: 0,\n      y: 0\n    };\n    this.endRightPx = {\n      x: 0,\n      y: 0\n    };\n    this.tipBaseLeftPx = {\n      x: 0,\n      y: 0\n    };\n    this.tipBaseRightPx = {\n      x: 0,\n      y: 0\n    };\n    this.eraserTopLeftPx = {\n      x: 0,\n      y: 0\n    };\n    this.eraserTopRightPx = {\n      x: 0,\n      y: 0\n    };\n    this.eraserNeckLeftPx = {\n      x: 0,\n      y: 0\n    };\n    this.eraserNeckRightPx = {\n      x: 0,\n      y: 0\n    };\n    this.defaultPoints = [];\n    this.updatedPoints = [];\n    this.visible = false;\n    this.generatePoints();\n  }\n\n  _createClass(Pencil, [{\n    key: \"setContext\",\n    value: function setContext(context, container) {\n      this.context = context;\n      this.container = container;\n      this.testVector = new _items_Vector__WEBPACK_IMPORTED_MODULE_0__[\"Vector\"]({\n        x: 0,\n        y: 0\n      }, {\n        x: 1,\n        y: 1\n      }, {\n        color: \"#ff9223\"\n      }); // container.addItem(this.testVector);\n\n      this.updatePixelLocation();\n    }\n  }, {\n    key: \"generatePoints\",\n    value: function generatePoints() {\n      var defaultAngle = 0;\n      this.pencilVectorD = new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"](Math.cos(0) * this.length, Math.sin(0) * this.length);\n      this.pencilVector = this.pencilVectorD.clone();\n      this.pencilUVect = funcs.getUnitVector(this.pencilVector);\n      this.normalUVect = {\n        x: -this.pencilUVect.y,\n        y: this.pencilUVect.x\n      };\n      this.tipBase = new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"](this.pencilUVect.x * this.tipLength, this.pencilUVect.y * this.tipLength);\n      this.tipBaseLeftD = new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"](this.tipBase.x + this.normalUVect.x * this.tipBaseHalfWidth, this.tipBase.y + this.normalUVect.y * this.tipBaseHalfWidth);\n      this.defaultPoints.push(this.tipBaseLeftD);\n      this.tipBaseLeft = this.tipBaseLeftD.clone();\n      this.updatedPoints.push(this.tipBaseLeft);\n      this.tipBaseRightD = new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"](this.tipBase.x - this.normalUVect.x * this.tipBaseHalfWidth, this.tipBase.y - this.normalUVect.y * this.tipBaseHalfWidth);\n      this.defaultPoints.push(this.tipBaseRightD);\n      this.tipBaseRight = this.tipBaseRightD.clone();\n      this.updatedPoints.push(this.tipBaseRight);\n      this.pencilNeckD = new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"](this.pencilUVect.x * this.headLength, this.pencilUVect.y * this.headLength);\n      this.defaultPoints.push(this.pencilNeckD);\n      this.pencilNeck = this.pencilNeckD.clone();\n      this.updatedPoints.push(this.pencilNeck);\n      this.neckLeftD = new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"](this.pencilNeck.x + this.normalUVect.x * this.halfWidth, this.pencilNeck.y + this.normalUVect.y * this.halfWidth);\n      this.defaultPoints.push(this.neckLeftD);\n      this.neckLeft = this.neckLeftD.clone();\n      this.updatedPoints.push(this.neckLeft);\n      this.neckRightD = new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"](this.pencilNeck.x - this.normalUVect.x * this.halfWidth, this.pencilNeck.y - this.normalUVect.y * this.halfWidth);\n      this.defaultPoints.push(this.neckRightD);\n      this.neckRight = this.neckRightD.clone();\n      this.updatedPoints.push(this.neckRight);\n      this.endLeftD = new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"](this.pencilVector.x + this.normalUVect.x * this.halfWidth, this.pencilVector.y + this.normalUVect.y * this.halfWidth);\n      this.defaultPoints.push(this.endLeftD);\n      this.endLeft = this.endLeftD.clone();\n      this.updatedPoints.push(this.endLeft);\n      this.endRightD = new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"](this.pencilVector.x - this.normalUVect.x * this.halfWidth, this.pencilVector.y - this.normalUVect.y * this.halfWidth);\n      this.defaultPoints.push(this.endRightD);\n      this.endRight = this.endRightD.clone();\n      this.updatedPoints.push(this.endRight);\n      this.vectorEraserNeckD = new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"](Math.cos(defaultAngle) * (this.length + this.eraserHeight), Math.sin(defaultAngle) * (this.length + this.eraserHeight));\n      this.defaultPoints.push(this.vectorEraserNeckD);\n      this.vectorEraserNeck = this.vectorEraserNeckD.clone();\n      this.updatedPoints.push(this.vectorEraserNeck);\n      this.eraserNeckLeftD = new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"](this.vectorEraserNeck.x + this.normalUVect.x * this.halfWidth, this.vectorEraserNeck.y + this.normalUVect.y * this.halfWidth);\n      this.defaultPoints.push(this.eraserNeckLeftD);\n      this.eraserNeckLeft = this.eraserNeckLeftD.clone();\n      this.updatedPoints.push(this.eraserNeckLeft);\n      this.eraserNeckRightD = new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"](this.vectorEraserNeck.x - this.normalUVect.x * this.halfWidth, this.vectorEraserNeck.y - this.normalUVect.y * this.halfWidth);\n      this.defaultPoints.push(this.eraserNeckRightD);\n      this.eraserNeckRight = this.eraserNeckRightD.clone();\n      this.updatedPoints.push(this.eraserNeckRight);\n      this.vectorEraserEndD = new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"](Math.cos(defaultAngle) * (this.length + this.eraserHeight + .22), Math.sin(defaultAngle) * (this.length + this.eraserHeight + .22));\n      this.defaultPoints.push(this.vectorEraserEndD);\n      this.vectorEraserEnd = this.vectorEraserEndD.clone();\n      this.updatedPoints.push(this.vectorEraserEnd);\n      this.eraserTopLeftD = new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"](this.vectorEraserEnd.x + this.normalUVect.x * this.halfWidth, this.vectorEraserEnd.y + this.normalUVect.y * this.halfWidth);\n      this.defaultPoints.push(this.eraserTopLeftD);\n      this.eraserTopLeft = this.eraserTopLeftD.clone();\n      this.updatedPoints.push(this.eraserTopLeft);\n      this.eraserTopRightD = new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"](this.vectorEraserEnd.x - this.normalUVect.x * this.halfWidth, this.vectorEraserEnd.y - this.normalUVect.y * this.halfWidth);\n      this.defaultPoints.push(this.eraserTopRightD);\n      this.eraserTopRight = this.eraserTopRightD.clone();\n      this.updatedPoints.push(this.eraserTopRight);\n    }\n  }, {\n    key: \"move\",\n    value: function move(pt) {\n      this.pos = pt;\n\n      for (var i = 0; i < this.defaultPoints.length; i++) {\n        this.updatedPoints[i].x = this.r1_c1 * this.defaultPoints[i].x + this.r1_c2 * this.defaultPoints[i].y + pt.x;\n        this.updatedPoints[i].y = this.r2_c1 * this.defaultPoints[i].x + this.r2_c2 * this.defaultPoints[i].y + pt.y;\n      }\n\n      this.updatePixelLocation();\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      var _this = this;\n\n      var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      new TWEEN.Tween({\n        opacity: this.globalAlpha\n      }).to({\n        opacity: 0\n      }, 400).easing(TWEEN.Easing.Sinusoidal.In).delay(delay).on('update', function (value) {// this.globalAlpha = value.opacity;\n      }).on(\"complete\", function () {\n        _this.visible = false;\n      }).start();\n    }\n  }, {\n    key: \"prepareToDrawLine\",\n    value: function prepareToDrawLine(fromPt, toPt, readyCallback) {\n      var _this2 = this;\n\n      // // vector from start to end...\n      this.lineVector = {\n        x: toPt.x - fromPt.x,\n        y: toPt.y - fromPt.y\n      };\n      this.unitLineVector = funcs.getUnitVector(this.lineVector); // this.testVector.update(fromPt, this.lineVector)\n\n      this.angle = funcs.getAngleCC(this.lineVector);\n      var inclinationAngle;\n\n      if (0 <= this.angle && this.angle < Math.PI) {\n        // subtract pencil inclination angle..\n        inclinationAngle = this.angle - this.pencilInclinationAngle;\n      } else {\n        // add \n        inclinationAngle = this.angle + this.pencilInclinationAngle;\n      } // rotate inclinationAngle angle..\n\n\n      this.r1_c1 = Math.cos(inclinationAngle);\n      this.r1_c2 = -Math.sin(inclinationAngle);\n      this.r2_c1 = Math.sin(inclinationAngle);\n      this.r2_c2 = Math.cos(inclinationAngle);\n      this.updatePixelLocation();\n      var fadeInTween = new TWEEN.Tween({\n        opacity: 0\n      }).to({\n        opacity: 1\n      }, 600).easing(TWEEN.Easing.Circular.In).on('update', function (value) {// this.globalAlpha = value.opacity;\n      }).on(\"complete\", function () {\n        if (readyCallback) {\n          setTimeout(readyCallback, 300);\n        }\n      });\n\n      if (this.visible) {\n        new TWEEN.Tween({\n          opacity: 1\n        }).to({\n          opacity: 0\n        }, 400).easing(TWEEN.Easing.Sinusoidal.Out).on('update', function (value) {// this.globalAlpha = value.opacity;\n        }).on(\"complete\", function () {\n          _this2.move(fromPt);\n\n          _this2.updatePixelLocation();\n\n          fadeInTween.start();\n        }).start();\n      } else {\n        // this.globalAlpha = 0;\n        this.move(fromPt);\n        this.visible = true;\n        fadeInTween.start();\n      }\n    }\n  }, {\n    key: \"prepareToDrawPoint\",\n    value: function prepareToDrawPoint(pt, readyCallback) {} // this method must be implemented in all Item class\n\n  }, {\n    key: \"updatePixelLocation\",\n    value: function updatePixelLocation() {\n      this.container.getPixFromCoorPtFT(this.pos, this.posPx);\n      this.container.getPixFromCoorPtFT(this.tipBaseLeft, this.tipBaseLeftPx);\n      this.container.getPixFromCoorPtFT(this.tipBaseRight, this.tipBaseRightPx);\n      this.container.getPixFromCoorPtFT(this.neckLeft, this.neckLeftPx);\n      this.container.getPixFromCoorPtFT(this.neckRight, this.neckRightPx);\n      this.container.getPixFromCoorPtFT(this.endLeft, this.endLeftPx);\n      this.container.getPixFromCoorPtFT(this.endRight, this.endRightPx);\n      this.container.getPixFromCoorPtFT(this.eraserTopLeft, this.eraserTopLeftPx);\n      this.container.getPixFromCoorPtFT(this.eraserTopRight, this.eraserTopRightPx);\n      this.container.getPixFromCoorPtFT(this.eraserNeckLeft, this.eraserNeckLeftPx);\n      this.container.getPixFromCoorPtFT(this.eraserNeckRight, this.eraserNeckRightPx);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      if (!this.visible) {\n        return;\n      } // this.context.save();\n\n\n      this.context.globalAlpha = this.globalAlpha;\n      this.context.lineJoin = 'round';\n      this.context.lineWidth = 1;\n      this.context.strokeStyle = \"#000000\";\n      this.context.fillStyle = \"#000000\";\n      this.context.beginPath();\n      this.context.moveTo(this.posPx.x, this.posPx.y);\n      this.context.lineTo(this.tipBaseLeftPx.x, this.tipBaseLeftPx.y);\n      this.context.lineTo(this.tipBaseRightPx.x, this.tipBaseRightPx.y);\n      this.context.stroke();\n      this.context.fill();\n      this.context.strokeStyle = \"#ceaf9a\";\n      this.context.fillStyle = \"#DEBFAA\";\n      this.context.beginPath();\n      this.context.moveTo(this.tipBaseLeftPx.x, this.tipBaseLeftPx.y);\n      this.context.lineTo(this.neckLeftPx.x, this.neckLeftPx.y);\n      this.context.lineTo(this.neckRightPx.x, this.neckRightPx.y);\n      this.context.lineTo(this.tipBaseRightPx.x, this.tipBaseRightPx.y);\n      this.context.fill();\n      this.context.stroke();\n      this.context.strokeStyle = \"#4d4072\";\n      this.context.fillStyle = \"#5c4b89\";\n      this.context.beginPath();\n      this.context.moveTo(this.neckLeftPx.x, this.neckLeftPx.y);\n      this.context.lineTo(this.endLeftPx.x, this.endLeftPx.y);\n      this.context.lineTo(this.endRightPx.x, this.endRightPx.y);\n      this.context.lineTo(this.neckRightPx.x, this.neckRightPx.y);\n      this.context.fill();\n      this.context.stroke();\n      this.context.strokeStyle = \"#91323c\";\n      this.context.fillStyle = \"#B03543\";\n      this.context.beginPath();\n      this.context.moveTo(this.endLeftPx.x, this.endLeftPx.y);\n      this.context.lineTo(this.eraserNeckLeftPx.x, this.eraserNeckLeftPx.y);\n      this.context.bezierCurveTo(this.eraserTopLeftPx.x, this.eraserTopLeftPx.y, this.eraserTopRightPx.x, this.eraserTopRightPx.y, this.eraserNeckRightPx.x, this.eraserNeckRightPx.y);\n      this.context.lineTo(this.endRightPx.x, this.endRightPx.y);\n      this.context.fill();\n      this.context.stroke(); // this.context.restore();\n    } // implements in all instruments\n\n  }, {\n    key: \"adjustScale\",\n    value: function adjustScale() {}\n  }]);\n\n  return Pencil;\n}();\n\n//# sourceURL=webpack://threeD/./src/v2_geometry/instruments/Pencil.js?");

/***/ }),

/***/ "./src/v2_geometry/instruments/Protractor.js":
/*!***************************************************!*\
  !*** ./src/v2_geometry/instruments/Protractor.js ***!
  \***************************************************/
/*! exports provided: Protractor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Protractor\", function() { return Protractor; });\n/* harmony import */ var _Vector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Vector2 */ \"./src/v2_geometry/Vector2.js\");\n/* harmony import */ var _utils_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/constants */ \"./src/v2_geometry/utils/constants.js\");\n/* harmony import */ var _utils_constants__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_utils_constants__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _items_Vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../items/Vector */ \"./src/v2_geometry/items/Vector.js\");\n/* harmony import */ var es6_tween__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! es6-tween */ \"C:\\\\Users\\\\XiaoMi\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\es6-tween\\\\bundled\\\\Tween.min.js\");\n/* harmony import */ var es6_tween__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(es6_tween__WEBPACK_IMPORTED_MODULE_3__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\nvar funcs = __webpack_require__(/*! ../utils/funcs */ \"./src/v2_geometry/utils/funcs.js\");\n\nvar TWEEN = __webpack_require__(/*! es6-tween */ \"C:\\\\Users\\\\XiaoMi\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\es6-tween\\\\bundled\\\\Tween.min.js\");\n\n\nObject(es6_tween__WEBPACK_IMPORTED_MODULE_3__[\"autoPlay\"])(true);\nvar Protractor = /*#__PURE__*/function () {\n  function Protractor(config) {\n    _classCallCheck(this, Protractor);\n\n    this.pos = new _Vector2__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](1, 0);\n    this.posPx = new _Vector2__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]();\n    this.radius = 6;\n    this.type = \"Protractor\";\n    this.visible = false;\n    this.color = \"#000000\";\n    this.tickColor = \"#000000\";\n    this.textColor = \"#000000\";\n    this.tickLineWidth = 1;\n    this.labelSizeInCoor = .25;\n    this.labelSize90Coor = .48;\n\n    for (var objName in config) {\n      if (this[objName] == undefined) {\n        console.warn(Protractor.name + \": \" + objName + \" parameter is undefined.\");\n      }\n\n      this[objName] = config[objName];\n    }\n\n    this.minorTickLen = .4;\n    this.midTickLen = .65;\n    this.majorTickLen = .7;\n    this.outerLbPosRadius = 4.86;\n    this.middleArcRadius = 4.76;\n    this.innerLbPosRadius = 4;\n    this.innerArcRadius = 4;\n    this.rightAngLineLen = 4.3;\n    this.innerMostArcR = 1.2;\n    this.distLbsCoor = .6;\n    this.PIBy180 = Math.PI / 180;\n    this.PIBy18 = Math.PI / 18;\n    this.tickPtStarts = [];\n    this.tickPtEnds = [];\n    this.outerLabelPos = [];\n    this.innerLabelPos = [];\n    this.raysPosStart = [];\n    this.raysPosEnd = [];\n\n    for (var i = 0; i <= 180; i++) {\n      this.tickPtStarts[i] = new _Vector2__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]();\n      this.tickPtEnds[i] = new _Vector2__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]();\n    }\n\n    for (var _i = 0; _i <= 18; _i++) {\n      this.outerLabelPos.push(new _Vector2__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]());\n      this.innerLabelPos.push(new _Vector2__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]());\n      this.raysPosStart.push(new _Vector2__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]());\n      this.raysPosEnd.push(new _Vector2__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]());\n    }\n\n    this.tempAngle = 0;\n    this.startAngle = 0;\n    this.numberCanvases = [];\n    this.numberWidths = [];\n    this.numberStartX = [];\n    this.noCanvasImgWidths = [];\n    this.noCanvasImgHeights = [];\n    this.defaultBorderOpacity = .3;\n    this.defaultInnerOpacity = .4;\n    this.defaultTextOpacity = 1;\n    this.defaultTickOpacity = 1;\n    this.colorRGB = funcs.hexToRgb(this.color);\n    this.tickColorRGB = funcs.hexToRgb(this.tickColor);\n    this.textColorRGB = funcs.hexToRgb(this.textColor);\n    this.borderColorA = \"rgba(\" + this.colorRGB[0] + \", \" + this.colorRGB[1] + \", \" + this.colorRGB[2] + \", \" + 0 + \")\";\n    this.innerColorA = \"rgba(\" + this.colorRGB[0] + \", \" + this.colorRGB[1] + \", \" + this.colorRGB[2] + \", \" + 0 + \")\";\n    this.tickColorA = \"rgba(\" + this.tickColorRGB[0] + \", \" + this.tickColorRGB[1] + \", \" + this.tickColorRGB[2] + \", \" + 0 + \")\";\n    this.textColorA = \"rgba(\" + this.textColorRGB[0] + \", \" + this.textColorRGB[1] + \", \" + this.textColorRGB[2] + \", \" + 0 + \")\";\n    this.pannable = true; // some temp variables..\n\n    this.diffFromCenter = new _Vector2__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]();\n  }\n\n  _createClass(Protractor, [{\n    key: \"setContext\",\n    value: function setContext(context, container) {\n      this.context = context;\n      this.container = container;\n      this.defaultTransform = this.context.getTransform();\n      this.testVector = new _items_Vector__WEBPACK_IMPORTED_MODULE_2__[\"Vector\"]({\n        x: 0,\n        y: 0\n      }, {\n        x: 1,\n        y: 1\n      }, {\n        color: \"#ff9223\",\n        lineWidth: 4\n      });\n      container.addItem(this.testVector);\n      this.testVector1 = new _items_Vector__WEBPACK_IMPORTED_MODULE_2__[\"Vector\"]({\n        x: 0,\n        y: 0\n      }, {\n        x: 1,\n        y: 1\n      }, {\n        color: \"#ff1223\",\n        lineWidth: 4\n      });\n      container.addItem(this.testVector1);\n      var w = 100;\n      var h = 50;\n      this.noCanvasWidth = Math.round(w * this.container.devicePixelRatio) / this.container.devicePixelRatio;\n      this.noCanvasHeight = Math.round(h * this.container.devicePixelRatio) / this.container.devicePixelRatio;\n\n      for (var i = 0; i <= 18; i++) {\n        var newCanvas = document.createElement(\"canvas\");\n        newCanvas.style.width = w + \"px\";\n        newCanvas.style.height = h + \"px\";\n        newCanvas.width = Math.round(w * this.container.devicePixelRatio);\n        newCanvas.height = Math.round(h * this.container.devicePixelRatio);\n\n        var _textContext = newCanvas.getContext(\"2d\", {\n          alpha: true\n        });\n\n        _textContext.scale(this.container.devicePixelRatio, this.container.devicePixelRatio);\n\n        _textContext.fillStyle = '#00000';\n        _textContext.font = '' + 10 + 'px Arial';\n\n        var _text = i * 10;\n\n        var _metrics = _textContext.measureText(_text); // textContext.textBaseline = 'middle';\n\n\n        _textContext.fillText(i * 10, 0, 10);\n\n        this.numberCanvases.push(newCanvas);\n        this.numberWidths.push(_metrics.width);\n        this.numberStartX.push(-_metrics.width / 2);\n      }\n\n      this.canvas90 = document.createElement(\"canvas\");\n      w = 100;\n      h = 60;\n      this.canvas90.style.width = w + \"px\";\n      this.canvas90.style.height = h + \"px\";\n      this.canvas90.width = Math.round(w * this.container.devicePixelRatio);\n      this.canvas90.height = Math.round(h * this.container.devicePixelRatio);\n      var textContext = this.canvas90.getContext(\"2d\", {\n        alpha: true\n      });\n      textContext.scale(this.container.devicePixelRatio, this.container.devicePixelRatio);\n      textContext.fillStyle = '#00000';\n      textContext.font = '' + 22 + 'px Arial';\n      var text = \"90\";\n      var metrics = textContext.measureText(text);\n      this.text90Width = metrics.width;\n      textContext.fillText(text, 0, metrics.actualBoundingBoxAscent);\n      this.canvas90Width = this.canvas90.width / this.container.devicePixelRatio;\n      this.canvas90Height = this.canvas90.height / this.container.devicePixelRatio; // this.prepareToMesure({ x: 2, y: -1.2 }, { x: -3, y: 1.2 }, 2);\n      // this.updatePixelLocation();\n      // this.adjustScale();\n    } // arc in counter clockwise direction...\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      if (!this.visible) {\n        return;\n      }\n\n      this.context.beginPath();\n      this.context.lineWidth = this.tickLineWidth;\n      this.context.strokeStyle = this.borderColorA;\n      this.context.fillStyle = this.innerColorA;\n      this.context.arc(this.posPx.x, this.posPx.y, this.radiusPx, this.startCanvasAngleOF, this.endCanvasAngleOF, true);\n      this.context.closePath();\n      this.context.stroke();\n      this.context.fill();\n      this.context.strokeStyle = this.tickColorA;\n      this.context.beginPath();\n      this.context.arc(this.posPx.x, this.posPx.y, this.middleArcRadiusPx, this.startCanvasAngle, this.startCanvasAngle - 1.4835298642, true);\n      this.context.stroke();\n      this.context.beginPath();\n      this.context.arc(this.posPx.x, this.posPx.y, this.middleArcRadiusPx, this.endCanvasAngle + 1.4835298642, this.endCanvasAngle, true);\n      this.context.stroke();\n      this.context.beginPath();\n      this.context.arc(this.posPx.x, this.posPx.y, this.innerArcRadiusPx, this.startCanvasAngle, this.endCanvasAngle, true);\n      this.context.arc(this.posPx.x, this.posPx.y, this.innerMostArcRPx, this.startCanvasAngle, this.endCanvasAngle, true);\n\n      for (var i = 0; i < this.tickPtStarts.length; i++) {\n        this.context.moveTo(this.tickPtStarts[i].x, this.tickPtStarts[i].y);\n        this.context.lineTo(this.tickPtEnds[i].x, this.tickPtEnds[i].y);\n      }\n\n      this.context.fillStyle = this.textColorA;\n      this.context.textAlign = \"center\";\n\n      for (var _i2 = 0; _i2 <= 18; _i2++) {\n        this.context.translate(this.outerLabelPos[_i2].x, this.outerLabelPos[_i2].y);\n        this.context.rotate(this.lbStartAngle - _i2 * this.PIBy18);\n\n        if (_i2 == 9) {\n          this.context.font = this.labelFont90; // this.context.drawImage(this.canvas90, this.text90Width / -2 , (this.distLbsCoorPx / 4) + (this.labelSize90CoorPx / 2), this.canvas90Width, this.canvas90Height);\n\n          this.context.fillText(\"90\", 0, this.labelSize90CoorPx);\n        } else {\n          this.context.font = this.labelFont;\n          this.context.fillText(_i2 * 10, 0, 0);\n          this.context.fillText((18 - _i2) * 10, 0, this.distLbsCoorPx);\n        }\n\n        this.context.rotate(-(this.lbStartAngle - _i2 * this.PIBy18));\n        this.context.translate(-this.outerLabelPos[_i2].x, -this.outerLabelPos[_i2].y);\n      }\n\n      this.context.setTransform(this.defaultTransform);\n\n      for (var _i3 = 1; _i3 <= 18; _i3++) {\n        this.context.moveTo(this.raysPosStart[_i3].x, this.raysPosStart[_i3].y);\n        this.context.lineTo(this.raysPosEnd[_i3].x, this.raysPosEnd[_i3].y);\n      }\n\n      this.context.moveTo(this.raysPosEnd[0].x, this.raysPosEnd[0].y);\n      this.context.lineTo(this.raysPosEnd[18].x, this.raysPosEnd[18].y);\n      this.context.moveTo(this.posPx.x, this.posPx.y);\n      this.context.lineTo(this.raysPosEnd[9].x, this.raysPosEnd[9].y);\n      this.context.stroke();\n    }\n  }, {\n    key: \"prepareToMesure\",\n    value: function prepareToMesure(ptOrigin, ptEnd, angle) {\n      var _this = this;\n\n      var oldStartAngle = this.startAngle;\n      var vect = {\n        x: ptEnd.x - ptOrigin.x,\n        y: ptEnd.y - ptOrigin.y\n      };\n      this.testVector.update(ptOrigin, vect);\n      var newStartAngle = funcs.getAngleCC(vect);\n\n      if (angle < 0) {\n        newStartAngle = newStartAngle + Math.PI;\n      }\n\n      newStartAngle = newStartAngle % _utils_constants__WEBPACK_IMPORTED_MODULE_1___default.a.TWO_PI;\n\n      if (oldStartAngle > newStartAngle) {\n        if (oldStartAngle - newStartAngle > Math.PI) {\n          oldStartAngle = -(_utils_constants__WEBPACK_IMPORTED_MODULE_1___default.a.TWO_PI - oldStartAngle);\n        }\n      } else {\n        if (newStartAngle - oldStartAngle > Math.PI) {\n          newStartAngle = -(_utils_constants__WEBPACK_IMPORTED_MODULE_1___default.a.TWO_PI - newStartAngle);\n        }\n      } // console.log(\".......................\")\n      // console.log(\"old start angle  \" + oldStartAngle);\n      // console.log('new start angle ' + newStartAngle)\n      // console.log(\"ptorigin\")\n      // console.log(ptOrigin)\n      // console.log(\"pt end \")\n      // console.log(ptEnd)\n      // console.log('angle to measure ' + angle)\n      // console.log(\"..............\")\n      // console.log(\"newAngle \" + newStartAngle);\n      // if(Math.abs(newStartAngle) > Math.PI){\n      //     newStartAngle = - (constants.TWO_PI - newStartAngle)\n      //     console.log(\"changed... \" + newStartAngle);\n      // }\n\n\n      if (!this.visible) {\n        this.pos.x = ptOrigin.x;\n        this.pos.y = ptOrigin.y;\n        this.startAngle = newStartAngle;\n        this.updatePixelLocation();\n        new es6_tween__WEBPACK_IMPORTED_MODULE_3__[\"Tween\"]({\n          opacity: 0\n        }).to({\n          opacity: 1\n        }, 900).easing(TWEEN.Easing.Sinusoidal.InOut).on('start', function () {\n          _this.lbStartAngle = -_utils_constants__WEBPACK_IMPORTED_MODULE_1___default.a.THREE_PI_BY_2 - _this.startAngle;\n\n          _this.adjustScale();\n\n          _this.visible = true;\n        }).on('update', function (value) {\n          _this.borderColorA = \"rgba(\" + _this.colorRGB[0] + \", \" + _this.colorRGB[1] + \", \" + _this.colorRGB[2] + \", \" + value.opacity * _this.defaultBorderOpacity + \")\";\n          _this.innerColorA = \"rgba(\" + _this.colorRGB[0] + \", \" + _this.colorRGB[1] + \", \" + _this.colorRGB[2] + \", \" + value.opacity * _this.defaultInnerOpacity + \")\";\n          _this.tickColorA = \"rgba(\" + _this.tickColorRGB[0] + \", \" + _this.tickColorRGB[1] + \", \" + _this.tickColorRGB[2] + \", \" + value.opacity * _this.defaultTickOpacity + \")\";\n          _this.textColorA = \"rgba(\" + _this.textColorRGB[0] + \", \" + _this.textColorRGB[1] + \", \" + _this.textColorRGB[2] + \", \" + value.opacity * _this.defaultTextOpacity + \")\";\n        }).on(\"complete\", function () {}).start();\n      } else {\n        new es6_tween__WEBPACK_IMPORTED_MODULE_3__[\"Tween\"]({\n          x: this.pos.x,\n          y: this.pos.y,\n          startAngle: oldStartAngle,\n          textAngTimer: 0\n        }).to({\n          x: ptOrigin.x,\n          y: ptOrigin.y,\n          startAngle: newStartAngle,\n          textAngTimer: 1\n        }, 900).easing(TWEEN.Easing.Sinusoidal.InOut).on('update', function (value) {\n          _this.pos.x = value.x;\n          _this.pos.y = value.y;\n          _this.startAngle = value.startAngle;\n\n          if (value.textAngTimer <= 0.6) {\n            _this.textColorA = \"rgba(\" + _this.textColorRGB[0] + \", \" + _this.textColorRGB[1] + \", \" + _this.textColorRGB[2] + \", \" + (1 - value.textAngTimer / 0.6) + \")\";\n          } else if (value.textAngTimer > 0.8) {\n            _this.textColorA = \"rgba(\" + _this.textColorRGB[0] + \", \" + _this.textColorRGB[1] + \", \" + _this.textColorRGB[2] + \", \" + (1 - (1 - value.textAngTimer) / 0.2) + \")\";\n          } else if (value.textAngTimer > 0.6 && !_this.textAngChanged) {\n            _this.lbStartAngle = -_utils_constants__WEBPACK_IMPORTED_MODULE_1___default.a.THREE_PI_BY_2 - newStartAngle;\n            _this.textAngChanged = true;\n          }\n\n          _this.updatePixelLocation();\n        }).on(\"complete\", function () {\n          // this.startCanvasAngle = -(this.startAngle);\n          _this.textAngChanged = false;\n        }).start();\n      }\n    }\n  }, {\n    key: \"generatePoints\",\n    value: function generatePoints() {\n      this.startCanvasAngle = -this.startAngle;\n      this.startCanvasAngleOF = -(this.startAngle - .1);\n      this.endCanvasAngle = -(this.startAngle + Math.PI);\n      this.endCanvasAngleOF = -(this.startAngle + (Math.PI + .1));\n      this.lbRotationAngle = -_utils_constants__WEBPACK_IMPORTED_MODULE_1___default.a.THREE_PI_BY_2 + this.startCanvasAngle;\n\n      for (var i = 0; i <= 180; i++) {\n        this.tempAngle = this.startAngle + this.PIBy180 * i;\n        this.tickPtStarts[i].x = this.posPx.x + this.radiusPx * Math.cos(this.tempAngle);\n        this.tickPtStarts[i].y = this.posPx.y + -Math.sin(this.tempAngle) * this.radiusPx;\n\n        if (i % 10 == 0) {\n          if (i == 90) {\n            this.tickPtEnds[i].x = this.posPx.x + this.majorTickEnd * Math.cos(this.tempAngle);\n            this.tickPtEnds[i].y = this.posPx.y + -Math.sin(this.tempAngle) * this.majorTickEnd;\n          } else {\n            this.tickPtEnds[i].x = this.posPx.x + this.majorTickEnd * Math.cos(this.tempAngle);\n            this.tickPtEnds[i].y = this.posPx.y + -Math.sin(this.tempAngle) * this.majorTickEnd;\n          }\n        } else if (i % 5 == 0) {\n          this.tickPtEnds[i].x = this.posPx.x + this.midTickEnd * Math.cos(this.tempAngle);\n          this.tickPtEnds[i].y = this.posPx.y + -Math.sin(this.tempAngle) * this.midTickEnd;\n        } else {\n          this.tickPtEnds[i].x = this.posPx.x + this.minorTickEnd * Math.cos(this.tempAngle);\n          this.tickPtEnds[i].y = this.posPx.y + -Math.sin(this.tempAngle) * this.minorTickEnd;\n        }\n      }\n\n      for (var _i4 = 0; _i4 <= 18; _i4++) {\n        this.tempAngle = this.startAngle + this.PIBy180 * _i4 * 10;\n        this.outerLabelPos[_i4].x = this.posPx.x + this.outerLbPosRadiusPx * Math.cos(this.tempAngle);\n        this.outerLabelPos[_i4].y = this.posPx.y + -Math.sin(this.tempAngle) * this.outerLbPosRadiusPx;\n        this.innerLabelPos[_i4].x = this.posPx.x + this.innerLbPosRadiusPx * Math.cos(this.tempAngle);\n        this.innerLabelPos[_i4].y = this.posPx.y + -Math.sin(this.tempAngle) * this.innerLbPosRadiusPx;\n\n        if (_i4 == 9) {\n          this.raysPosEnd[_i4].x = this.posPx.x + this.rightAngLineLenPx * Math.cos(this.tempAngle);\n          this.raysPosEnd[_i4].y = this.posPx.y + -Math.sin(this.tempAngle) * this.rightAngLineLenPx;\n          this.raysPosStart[_i4].x = this.raysPosEnd[_i4].x;\n          this.raysPosStart[_i4].y = this.raysPosEnd[_i4].y;\n        } else {\n          this.raysPosStart[_i4].x = this.posPx.x + this.innerMostArcRPx * Math.cos(this.tempAngle);\n          this.raysPosStart[_i4].y = this.posPx.y + -Math.sin(this.tempAngle) * this.innerMostArcRPx;\n          this.raysPosEnd[_i4].x = this.posPx.x + this.innerArcRadiusPx * Math.cos(this.tempAngle);\n          this.raysPosEnd[_i4].y = this.posPx.y + -Math.sin(this.tempAngle) * this.innerArcRadiusPx;\n        }\n      }\n    }\n  }, {\n    key: \"handlePanStart\",\n    value: function handlePanStart(ptPx) {\n      var _this2 = this;\n\n      if (funcs.getDistance(ptPx, this.posPx) < this.innerArcRadiusPx) {\n        this.toMove = true;\n        this.diffFromCenter.set(ptPx.x - this.posPx.x, ptPx.y - this.posPx.y);\n      } else {\n        this.toMove = false;\n        var ptCoor = this.container.getCoorFromPix(ptPx.x, ptPx.y);\n        var pointerAngle = funcs.getAngleCC({\n          x: ptCoor.x - this.pos.x,\n          y: ptCoor.y - this.pos.y\n        });\n        this.angleDiff = pointerAngle - this.startAngle;\n        new es6_tween__WEBPACK_IMPORTED_MODULE_3__[\"Tween\"]({\n          opacity: 1\n        }).to({\n          opacity: 0\n        }, 400).easing(TWEEN.Easing.Quartic.Out).on(\"update\", function (value) {\n          _this2.textColorA = \"rgba(\" + _this2.textColorRGB[0] + \", \" + _this2.textColorRGB[1] + \", \" + _this2.textColorRGB[2] + \", \" + value.opacity + \")\";\n        }).start();\n      }\n    }\n  }, {\n    key: \"handlePanMove\",\n    value: function handlePanMove(ptPx) {\n      if (this.toMove) {\n        this.moveToPx(ptPx.x - this.diffFromCenter.x, ptPx.y - this.diffFromCenter.y);\n      } else {\n        var ptCoor = this.container.getCoorFromPix(ptPx.x, ptPx.y);\n        var pointerAngle = funcs.getAngleCC({\n          x: ptCoor.x - this.pos.x,\n          y: ptCoor.y - this.pos.y\n        });\n        this.startAngle = pointerAngle - this.angleDiff;\n        this.updatePixelLocation();\n      }\n    }\n  }, {\n    key: \"handlePanEnd\",\n    value: function handlePanEnd(ptPx) {\n      var _this3 = this;\n\n      if (!this.toMove) {\n        new es6_tween__WEBPACK_IMPORTED_MODULE_3__[\"Tween\"]({\n          opacity: 0\n        }).to({\n          opacity: 1\n        }, 500).easing(TWEEN.Easing.Quadratic.InOut).on(\"start\", function () {\n          _this3.lbStartAngle = -_utils_constants__WEBPACK_IMPORTED_MODULE_1___default.a.THREE_PI_BY_2 - _this3.startAngle;\n        }).on(\"update\", function (value) {\n          _this3.textColorA = \"rgba(\" + _this3.textColorRGB[0] + \", \" + _this3.textColorRGB[1] + \", \" + _this3.textColorRGB[2] + \", \" + value.opacity + \")\";\n        }).start();\n      }\n    }\n  }, {\n    key: \"moveToPx\",\n    value: function moveToPx(x, y) {\n      // x, y in pixel....\n      this.container.getCoorFromPixFT(x, y, this.pos);\n      this.updatePixelLocation();\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(angle) {\n      // angle in counter-clockwise\n      this.startAngle = angle;\n      this.updatePixelLocation();\n    }\n  }, {\n    key: \"updatePixelLocation\",\n    value: function updatePixelLocation() {\n      this.container.getPixFromCoorPtFT(this.pos, this.posPx);\n      this.radiusPx = this.radius / this.container.coorPerPixel;\n      this.minorTickEnd = this.radiusPx - this.minorTickLen / this.container.coorPerPixel;\n      this.majorTickEnd = this.radiusPx - this.majorTickLen / this.container.coorPerPixel;\n      this.midTickEnd = this.radiusPx - this.midTickLen / this.container.coorPerPixel;\n      this.outerLbPosRadiusPx = this.outerLbPosRadius / this.container.coorPerPixel;\n      this.innerLbPosRadiusPx = this.innerLbPosRadius / this.container.coorPerPixel;\n      this.middleArcRadiusPx = this.middleArcRadius / this.container.coorPerPixel;\n      this.innerArcRadiusPx = this.innerArcRadius / this.container.coorPerPixel;\n      this.innerMostArcRPx = this.innerMostArcR / this.container.coorPerPixel;\n      this.distLbsCoorPx = this.distLbsCoor / this.container.coorPerPixel;\n      this.rightAngLineLenPx = this.rightAngLineLen / this.container.coorPerPixel;\n      this.generatePoints();\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      var _this4 = this;\n\n      if (!this.visible) {\n        return;\n      }\n\n      new TWEEN.Tween({\n        opacity: 1\n      }).to({\n        opacity: 0\n      }, 500).easing(TWEEN.Easing.Sinusoidal.In).on('update', function (value) {\n        _this4.borderColorA = \"rgba(\" + _this4.colorRGB[0] + \", \" + _this4.colorRGB[1] + \", \" + _this4.colorRGB[2] + \", \" + value.opacity * _this4.defaultBorderOpacity + \")\";\n        _this4.innerColorA = \"rgba(\" + _this4.colorRGB[0] + \", \" + _this4.colorRGB[1] + \", \" + _this4.colorRGB[2] + \", \" + value.opacity * _this4.defaultInnerOpacity + \")\";\n        _this4.tickColorA = \"rgba(\" + _this4.tickColorRGB[0] + \", \" + _this4.tickColorRGB[1] + \", \" + _this4.tickColorRGB[2] + \", \" + value.opacity * _this4.defaultTickOpacity + \")\";\n        _this4.textColorA = \"rgba(\" + _this4.textColorRGB[0] + \", \" + _this4.textColorRGB[1] + \", \" + _this4.textColorRGB[2] + \", \" + value.opacity * _this4.defaultTextOpacity + \")\";\n      }).on('complete', function (value) {\n        _this4.visible = false;\n      }).start();\n    }\n  }, {\n    key: \"checkSelection\",\n    value: function checkSelection(ptPx) {\n      this.context.beginPath();\n      this.context.arc(this.posPx.x, this.posPx.y, this.radiusPx, this.startCanvasAngleOF, this.endCanvasAngleOF, true);\n      return this.context.isPointInPath(ptPx.x * this.container.devicePixelRatio, ptPx.y * this.container.devicePixelRatio);\n    } //implements in all instruments\n\n  }, {\n    key: \"adjustScale\",\n    value: function adjustScale() {\n      this.labelSize90CoorPx = this.labelSize90Coor / this.container.coorPerPixel;\n      this.labelFont = \"bold \" + (this.labelSizeInCoor / this.container.coorPerPixel).toFixed(1) + \"pt Computer Modern\";\n      this.labelFont90 = \"bold \" + this.labelSize90CoorPx.toFixed(1) + \"pt Computer Modern\"; // this.distBetweenMjrTicks = 1 / this.container.coorPerPixel;\n      // this.labelFont = \"bold \" + (this.labelSizeInCoor / this.container.coorPerPixel).toFixed(1) + \"pt Computer Modern\";\n    } // this method must be implemented in all Item classes\n\n  }, {\n    key: \"getBoundingBoxCoor\",\n    value: function getBoundingBoxCoor() {\n      return undefined;\n    }\n  }]);\n\n  return Protractor;\n}();\n\n//# sourceURL=webpack://threeD/./src/v2_geometry/instruments/Protractor.js?");

/***/ }),

/***/ "./src/v2_geometry/instruments/Ruler.js":
/*!**********************************************!*\
  !*** ./src/v2_geometry/instruments/Ruler.js ***!
  \**********************************************/
/*! exports provided: Ruler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Ruler\", function() { return Ruler; });\n/* harmony import */ var _items_Vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../items/Vector */ \"./src/v2_geometry/items/Vector.js\");\n/* harmony import */ var es6_tween__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! es6-tween */ \"C:\\\\Users\\\\XiaoMi\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\es6-tween\\\\bundled\\\\Tween.min.js\");\n/* harmony import */ var es6_tween__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(es6_tween__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/constants */ \"./src/v2_geometry/utils/constants.js\");\n/* harmony import */ var _utils_constants__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_utils_constants__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Vector2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Vector2 */ \"./src/v2_geometry/Vector2.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar funcs = __webpack_require__(/*! ../utils/funcs */ \"./src/v2_geometry/utils/funcs.js\");\n\n\n\nvar TWEEN = __webpack_require__(/*! es6-tween */ \"C:\\\\Users\\\\XiaoMi\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\es6-tween\\\\bundled\\\\Tween.min.js\");\n\n\n\n\nObject(es6_tween__WEBPACK_IMPORTED_MODULE_1__[\"autoPlay\"])(true);\nvar Ruler = /*#__PURE__*/function () {\n  function Ruler(config) {\n    _classCallCheck(this, Ruler);\n\n    this.rulerWidth = 2.5;\n    this.rulerLength = 20; // 20 cm , 8 inches ruler\n\n    this.endOffset = .5; // .5 cm\n\n    this.centiTickLength = .85;\n    this.tickDistFromFront = this.centiTickLength + .2;\n    this.halfCentiTickLength = .6;\n    this.milliTickLength = .4;\n    this.color = \"#ff0000\";\n    this.tickColor = \"#444444\";\n    this.textColor = \"#000000\";\n\n    for (var objName in config) {\n      if (this[objName] == undefined) {\n        console.warn(Ruler.name + \": \" + objName + \" parameter is undefined.\");\n      }\n\n      this[objName] = config[objName];\n    }\n\n    this.labelSizeInCoor = .3;\n    this.borderColor = this.color + \"88\";\n    this.type = \"Ruler\";\n    this.visible = false;\n    this.defaultBorderOpacity = .45;\n    this.defaultInnerOpacity = .4;\n    this.defaultTextOpacity = 1;\n    this.defaultTickOpacity = 1;\n    this.colorRGB = funcs.hexToRgb(this.color);\n    this.tickColorRGB = funcs.hexToRgb(this.tickColor);\n    this.textColorRGB = funcs.hexToRgb(this.textColor);\n    this.borderColorA = \"rgba(\" + this.colorRGB[0] + \", \" + this.colorRGB[1] + \", \" + this.colorRGB[2] + \", \" + 0 + \")\";\n    this.innerColorA = \"rgba(\" + this.colorRGB[0] + \", \" + this.colorRGB[1] + \", \" + this.colorRGB[2] + \", \" + 0 + \")\";\n    this.tickColorA = \"rgba(\" + this.tickColorRGB[0] + \", \" + this.tickColorRGB[1] + \", \" + this.tickColorRGB[2] + \", \" + 0 + \")\";\n    this.textColorA = \"rgba(\" + this.textColorRGB[0] + \", \" + this.textColorRGB[1] + \", \" + this.textColorRGB[2] + \", \" + 0 + \")\";\n    this.cmTickDirFactor = 0;\n    this.cmTickDirFactor1 = +1;\n    this.vectToMoveBackPx = {\n      x: 0,\n      y: 0\n    };\n    this.startPtPx = new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"]();\n    this.totalLength = this.endOffset * 2 + this.rulerLength;\n    this.fromPtPx = new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"]();\n    this.vector = new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"]();\n    this.unitVector = new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"]();\n    this.unitNormalVector = new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"]();\n    this.startPtPx = new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"]();\n    this.endPtPx = new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"]();\n    this.endPtBackPx = new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"]();\n    this.startPtBackPx = new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"]();\n    this.normalVector = new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"]();\n    var tickCountAll = this.rulerLength * 10;\n    this.tickStartsPx = [];\n    this.tickEndsPx = [];\n\n    for (var i = 0; i <= tickCountAll; i++) {\n      this.tickStartsPx.push(new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"]());\n      this.tickEndsPx.push(new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"]());\n    }\n\n    this.labelsPos = [];\n\n    for (var _i = 0; _i <= 20; _i++) {\n      this.labelsPos.push(new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"]());\n    }\n  }\n\n  _createClass(Ruler, [{\n    key: \"setContext\",\n    value: function setContext(context, container) {\n      this.context = context;\n      this.container = container;\n      this.fromPt = new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"](-13.915577381639636, -10.939421080115627);\n      this.toPt = new _Vector2__WEBPACK_IMPORTED_MODULE_3__[\"Vector2\"](-8.271002421318794, -7.024922997496031);\n      this.testVector = new _items_Vector__WEBPACK_IMPORTED_MODULE_0__[\"Vector\"](this.fromPt, this.fromPt.subtractFrom(this.toPt), {\n        color: \"#000000\"\n      });\n      container.addItem(this.testVector);\n      this.testVectorNormal = new _items_Vector__WEBPACK_IMPORTED_MODULE_0__[\"Vector\"](this.fromPt, this.fromPt.subtractFrom(this.toPt), {\n        color: \"#00ff00\"\n      }); // container.addItem(this.testVectorNormal);\n\n      this.faceLeft = this.getLeftFacing({\n        x: this.toPt.x - this.fromPt.x,\n        y: this.toPt.y - this.fromPt.y\n      });\n      this.adjustScale();\n      this.updatePixelLocation();\n    }\n  }, {\n    key: \"generatePoints\",\n    value: function generatePoints() {\n      this.vector.x = this.toPt.x - this.fromPt.x;\n      this.vector.y = this.toPt.y - this.fromPt.y;\n      funcs.getUnitVectorInplace(this.vector, this.unitVector);\n\n      if (this.getLeftFacing(this.vector)) {\n        // ruler body on left\n        this.normalVector.x = -this.unitVector.y * this.rulerWidth;\n        this.normalVector.y = this.unitVector.x * this.rulerWidth;\n      } else {\n        // on right\n        this.normalVector.x = this.unitVector.y * this.rulerWidth;\n        this.normalVector.y = -this.unitVector.x * this.rulerWidth;\n      }\n\n      funcs.getUnitVectorInplace(this.normalVector, this.unitNormalVector);\n      this.vectToMoveBackPx.x = this.unitNormalVector.x * 1.6; // move back 1.3 px\n\n      this.vectToMoveBackPx.y = this.unitNormalVector.y * -1.6; // move back 1.3 px\n\n      this.fromPtPx.x += this.vectToMoveBackPx.x;\n      this.fromPtPx.y += this.vectToMoveBackPx.y;\n      this.startPtPx.x = this.fromPtPx.x - this.unitVector.x * this.endOffsetPx;\n      this.startPtPx.y = +this.fromPtPx.y + this.unitVector.y * this.endOffsetPx;\n      this.endPtPx.x = this.startPtPx.x + this.unitVector.x * this.totalLengthPx;\n      this.endPtPx.y = this.startPtPx.y - this.unitVector.y * this.totalLengthPx;\n      this.endPtBackPx.x = this.endPtPx.x + this.unitNormalVector.x * this.rulerWidthPx;\n      this.endPtBackPx.y = this.endPtPx.y - this.unitNormalVector.y * this.rulerWidthPx;\n      this.startPtBackPx.x = this.startPtPx.x + this.unitNormalVector.x * this.rulerWidthPx;\n      this.startPtBackPx.y = this.startPtPx.y - this.unitNormalVector.y * this.rulerWidthPx;\n\n      for (var i = 0; i < this.tickStartsPx.length; i++) {\n        this.tickStartsPx[i].x = this.fromPtPx.x + this.unitVector.x * this.distBetweenMinorTicks * i;\n        this.tickStartsPx[i].y = this.fromPtPx.y - this.unitVector.y * this.distBetweenMinorTicks * i;\n\n        if (i % 10 == 0) {\n          this.labelsPos[i / 10].x = this.tickStartsPx[i].x + this.unitNormalVector.x * this.tickDistFromFrontPx;\n          this.labelsPos[i / 10].y = this.tickStartsPx[i].y - this.unitNormalVector.y * this.tickDistFromFrontPx;\n          this.tickEndsPx[i].x = this.tickStartsPx[i].x + this.unitNormalVector.x * this.centiTickLengthPx;\n          this.tickEndsPx[i].y = this.tickStartsPx[i].y - this.unitNormalVector.y * this.centiTickLengthPx;\n        } else if (i % 5 == 0) {\n          this.tickEndsPx[i].x = this.tickStartsPx[i].x + this.unitNormalVector.x * this.halfCentiTickLenPx;\n          this.tickEndsPx[i].y = this.tickStartsPx[i].y - this.unitNormalVector.y * this.halfCentiTickLenPx;\n        } else {\n          this.tickEndsPx[i].x = this.tickStartsPx[i].x + this.unitNormalVector.x * this.milliTickLengthPx;\n          this.tickEndsPx[i].y = this.tickStartsPx[i].y - this.unitNormalVector.y * this.milliTickLengthPx;\n        }\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      if (!this.visible) {\n        return;\n      } // this.context.globalAlpha = this.globalAlpha;\n\n\n      this.context.beginPath();\n      this.context.font = this.labelSize;\n      this.context.lineWidth = 1;\n      this.context.lineJoin = 'round';\n      this.context.strokeStyle = this.borderColorA;\n      this.context.moveTo(this.startPtPx.x, this.startPtPx.y);\n      this.context.lineTo(this.endPtPx.x, this.endPtPx.y);\n      this.context.lineTo(this.endPtBackPx.x, this.endPtBackPx.y);\n      this.context.lineTo(this.startPtBackPx.x, this.startPtBackPx.y);\n      this.context.closePath();\n      this.context.fillStyle = this.innerColorA;\n      this.context.stroke();\n      this.context.fill();\n      this.context.beginPath();\n      this.context.strokeStyle = this.tickColorA;\n\n      for (var i = 0; i < this.tickStartsPx.length; i++) {\n        this.context.moveTo(this.tickStartsPx[i].x, this.tickStartsPx[i].y);\n        this.context.lineTo(this.tickEndsPx[i].x, this.tickEndsPx[i].y);\n      }\n\n      this.context.stroke();\n      this.context.fillStyle = this.textColorA;\n      this.context.textAlign = \"center\";\n      this.context.textBaseline = 'Alphabetic';\n\n      for (var _i2 = 0; _i2 < this.labelsPos.length; _i2++) {\n        this.context.translate(this.labelsPos[_i2].x, this.labelsPos[_i2].y);\n        this.context.rotate(this.lbAngle);\n        this.context.fillText(_i2, 0, 0);\n        this.context.rotate(-this.lbAngle);\n        this.context.translate(-this.labelsPos[_i2].x, -this.labelsPos[_i2].y);\n      }\n    } // this method must be implemented in all Item class\n\n  }, {\n    key: \"updatePixelLocation\",\n    value: function updatePixelLocation() {\n      this.endOffsetPx = this.endOffset / this.container.coorPerPixel;\n      this.totalLengthPx = this.totalLength / this.container.coorPerPixel;\n      this.rulerWidthPx = this.rulerWidth / this.container.coorPerPixel;\n      this.container.getPixFromCoorPtFT(this.fromPt, this.fromPtPx);\n      this.generatePoints();\n    }\n  }, {\n    key: \"moveTo\",\n    value: function moveTo(ptStart, ptEnd, readyCallback) {\n      var _this = this;\n\n      var delay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      this.testVector.update(ptStart, {\n        x: ptEnd.x - ptStart.x,\n        y: ptEnd.y - ptStart.y\n      });\n      var oldFromPt;\n      var isLeftNew = this.getLeftFacing({\n        x: ptEnd.x - ptStart.x,\n        y: ptEnd.y - ptStart.y\n      });\n      this.unitVector = funcs.getUnitVector(this.vector);\n      this.faceLeft = this.getLeftFacing(this.vector);\n\n      if (this.faceLeft) {\n        if (isLeftNew) {\n          oldFromPt = this.fromPt;\n        } else {\n          oldFromPt = {\n            x: this.fromPt.x + this.unitVector.x * this.rulerLength,\n            y: this.fromPt.y + this.unitVector.y * this.rulerLength\n          };\n        }\n      } else {\n        if (!isLeftNew) {\n          oldFromPt = this.fromPt;\n        } else {\n          oldFromPt = {\n            x: this.fromPt.x + this.unitVector.x * this.rulerLength,\n            y: this.fromPt.y + this.unitVector.y * this.rulerLength\n          };\n        }\n      }\n\n      var oldCorrectedUnitVector = funcs.getUnitVector({\n        x: this.toPt.x - oldFromPt.x,\n        y: this.toPt.y - oldFromPt.y\n      });\n      var newVectorLen = funcs.getDistance(ptEnd, ptStart);\n      var newUnTranslatedVector = {\n        x: oldCorrectedUnitVector.x * newVectorLen,\n        y: oldCorrectedUnitVector.y * newVectorLen\n      }; // old angle - new angle\n\n      var angleToRotate = funcs.getAngleCC({\n        x: oldFromPt.x - this.toPt.x,\n        y: oldFromPt.y - this.toPt.y\n      }) - funcs.getAngleCC({\n        x: ptStart.x - ptEnd.x,\n        y: ptStart.y - ptEnd.y\n      });\n      var dx = ptStart.x - (Math.cos(angleToRotate) * oldFromPt.x + Math.sin(angleToRotate) * oldFromPt.y);\n      var dy = ptStart.y - (-Math.sin(angleToRotate) * oldFromPt.x + Math.cos(angleToRotate) * oldFromPt.y);\n      var oldStartCopy = {\n        x: oldFromPt.x,\n        y: oldFromPt.y\n      };\n      var r1_c1, r1_c2, r2_c1, r2_c2;\n\n      if (!this.visible) {\n        r1_c1 = Math.cos(angleToRotate);\n        r1_c2 = Math.sin(angleToRotate);\n        r2_c1 = -Math.sin(angleToRotate);\n        r2_c2 = Math.cos(angleToRotate);\n        this.fromPt.x = r1_c1 * oldStartCopy.x + r1_c2 * oldStartCopy.y + dx;\n        this.fromPt.y = r2_c1 * oldStartCopy.x + r2_c2 * oldStartCopy.y + dy;\n        this.toPt.x = this.fromPt.x + r1_c1 * newUnTranslatedVector.x + r1_c2 * newUnTranslatedVector.y;\n        this.toPt.y = this.fromPt.y + r2_c1 * newUnTranslatedVector.x + r2_c2 * newUnTranslatedVector.y;\n\n        if (!isLeftNew) {\n          this.lbAngle = funcs.getAngle({\n            x: ptEnd.x - ptStart.x,\n            y: ptEnd.y - ptStart.y\n          }) + Math.PI;\n        } else {\n          this.lbAngle = funcs.getAngle({\n            x: ptEnd.x - ptStart.x,\n            y: ptEnd.y - ptStart.y\n          });\n        }\n\n        this.updatePixelLocation();\n        new TWEEN.Tween({\n          opacity: 0\n        }).to({\n          opacity: 1\n        }, 600).easing(TWEEN.Easing.Sinusoidal.In).on('start', function () {\n          _this.visible = true;\n        }).on('update', function (value) {\n          _this.borderColorA = \"rgba(\" + _this.colorRGB[0] + \", \" + _this.colorRGB[1] + \", \" + _this.colorRGB[2] + \", \" + value.opacity * _this.defaultBorderOpacity + \")\";\n          _this.innerColorA = \"rgba(\" + _this.colorRGB[0] + \", \" + _this.colorRGB[1] + \", \" + _this.colorRGB[2] + \", \" + value.opacity * _this.defaultInnerOpacity + \")\";\n          _this.tickColorA = \"rgba(\" + _this.tickColorRGB[0] + \", \" + _this.tickColorRGB[1] + \", \" + _this.tickColorRGB[2] + \", \" + value.opacity * _this.defaultTickOpacity + \")\";\n          _this.textColorA = \"rgba(\" + _this.textColorRGB[0] + \", \" + _this.textColorRGB[1] + \", \" + _this.textColorRGB[2] + \", \" + value.opacity * _this.defaultTextOpacity + \")\";\n        }).on(\"complete\", function () {\n          if (readyCallback) {\n            readyCallback();\n          }\n        }).start();\n      } else {\n        new TWEEN.Tween({\n          dx: 0,\n          dy: 0,\n          angle: 0,\n          textAngTimer: 0\n        }).to({\n          dx: dx,\n          dy: dy,\n          angle: angleToRotate,\n          textAngTimer: 1\n        }, 1200).easing(TWEEN.Easing.Sinusoidal.Out).delay(delay).on(\"start\", function () {}).on('update', function (value) {\n          r1_c1 = Math.cos(value.angle);\n          r1_c2 = Math.sin(value.angle);\n          r2_c1 = -Math.sin(value.angle);\n          r2_c2 = Math.cos(value.angle);\n          _this.fromPt.x = r1_c1 * oldStartCopy.x + r1_c2 * oldStartCopy.y + value.dx;\n          _this.fromPt.y = r2_c1 * oldStartCopy.x + r2_c2 * oldStartCopy.y + value.dy;\n          _this.toPt.x = _this.fromPt.x + r1_c1 * newUnTranslatedVector.x + r1_c2 * newUnTranslatedVector.y;\n          _this.toPt.y = _this.fromPt.y + r2_c1 * newUnTranslatedVector.x + r2_c2 * newUnTranslatedVector.y;\n\n          if (value.textAngTimer <= 0.6) {\n            _this.textColorA = \"rgba(\" + _this.textColorRGB[0] + \", \" + _this.textColorRGB[1] + \", \" + _this.textColorRGB[2] + \", \" + (1 - value.textAngTimer / 0.6) + \")\";\n          } else if (value.textAngTimer > 0.8) {\n            _this.textColorA = \"rgba(\" + _this.textColorRGB[0] + \", \" + _this.textColorRGB[1] + \", \" + _this.textColorRGB[2] + \", \" + (1 - (1 - value.textAngTimer) / 0.2) + \")\";\n          } else if (value.textAngTimer > 0.6 && !_this.textAngChanged) {\n            if (!isLeftNew) {\n              _this.lbAngle = funcs.getAngle({\n                x: ptEnd.x - ptStart.x,\n                y: ptEnd.y - ptStart.y\n              }) + Math.PI;\n            } else {\n              _this.lbAngle = funcs.getAngle({\n                x: ptEnd.x - ptStart.x,\n                y: ptEnd.y - ptStart.y\n              });\n            }\n\n            _this.textAngChanged = true;\n          }\n\n          _this.updatePixelLocation();\n        }).on(\"complete\", function () {\n          if (readyCallback) {\n            readyCallback();\n          }\n\n          _this.textAngChanged = false;\n        }).start();\n      }\n\n      return;\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      var _this2 = this;\n\n      var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      if (!this.visible) {\n        return;\n      }\n\n      new TWEEN.Tween({\n        opacity: 1\n      }).to({\n        opacity: 0\n      }, 500).easing(TWEEN.Easing.Sinusoidal.In).delay(delay).on('update', function (value) {\n        _this2.borderColorA = \"rgba(\" + _this2.colorRGB[0] + \", \" + _this2.colorRGB[1] + \", \" + _this2.colorRGB[2] + \", \" + value.opacity * _this2.defaultBorderOpacity + \")\";\n        _this2.innerColorA = \"rgba(\" + _this2.colorRGB[0] + \", \" + _this2.colorRGB[1] + \", \" + _this2.colorRGB[2] + \", \" + value.opacity * _this2.defaultInnerOpacity + \")\";\n        _this2.tickColorA = \"rgba(\" + _this2.tickColorRGB[0] + \", \" + _this2.tickColorRGB[1] + \", \" + _this2.tickColorRGB[2] + \", \" + value.opacity * _this2.defaultTickOpacity + \")\";\n        _this2.textColorA = \"rgba(\" + _this2.textColorRGB[0] + \", \" + _this2.textColorRGB[1] + \", \" + _this2.textColorRGB[2] + \", \" + value.opacity * _this2.defaultTextOpacity + \")\";\n      }).on('complete', function (value) {\n        _this2.visible = false;\n      }).start();\n    } // implements in all instruments\n\n  }, {\n    key: \"adjustScale\",\n    value: function adjustScale() {\n      this.milliTickLengthPx = this.milliTickLength / this.container.coorPerPixel;\n      this.halfCentiTickLenPx = this.halfCentiTickLength / this.container.coorPerPixel;\n      this.centiTickLengthPx = this.centiTickLength / this.container.coorPerPixel;\n      this.tickDistFromFrontPx = this.tickDistFromFront / this.container.coorPerPixel;\n      this.distBetweenMjrTicks = 1 / this.container.coorPerPixel;\n      this.distBetweenMinorTicks = 0.1 / this.container.coorPerPixel;\n      this.labelSize = \"bold \" + (this.labelSizeInCoor / this.container.coorPerPixel).toFixed(1) + \"pt Computer Modern\";\n    } // this method must be implemented in all Item classes\n\n  }, {\n    key: \"getBoundingBoxCoor\",\n    value: function getBoundingBoxCoor() {\n      return undefined;\n    }\n  }, {\n    key: \"getLeftFacing\",\n    value: function getLeftFacing(vector) {\n      var angle = funcs.getAngleCC(vector);\n      return 0 <= angle && angle <= Math.PI;\n    }\n  }]);\n\n  return Ruler;\n}();\n\n//# sourceURL=webpack://threeD/./src/v2_geometry/instruments/Ruler.js?");

/***/ }),

/***/ "./src/v2_geometry/items/Circle.js":
/*!*****************************************!*\
  !*** ./src/v2_geometry/items/Circle.js ***!
  \*****************************************/
/*! exports provided: Circle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Circle\", function() { return Circle; });\n/* harmony import */ var _utils_Clock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Clock */ \"./src/v2_geometry/utils/Clock.js\");\n/* harmony import */ var es6_tween__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! es6-tween */ \"C:\\\\Users\\\\XiaoMi\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\es6-tween\\\\bundled\\\\Tween.min.js\");\n/* harmony import */ var es6_tween__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(es6_tween__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Vector2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Vector2 */ \"./src/v2_geometry/Vector2.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar CONSTS = __webpack_require__(/*! ../utils/constants */ \"./src/v2_geometry/utils/constants.js\");\n\nvar TWEEN = __webpack_require__(/*! es6-tween */ \"C:\\\\Users\\\\XiaoMi\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\es6-tween\\\\bundled\\\\Tween.min.js\");\n\nvar funcs = __webpack_require__(/*! ../utils/funcs */ \"./src/v2_geometry/utils/funcs.js\");\n\n\n\n // var THREE = require(\"three\");\n\nvar easings = __webpack_require__(/*! ../utils/easings */ \"./src/v2_geometry/utils/easings.js\");\n\nObject(es6_tween__WEBPACK_IMPORTED_MODULE_1__[\"autoPlay\"])(true);\nvar Circle = /*#__PURE__*/function () {\n  function Circle(center, radius, config) {\n    _classCallCheck(this, Circle);\n\n    this.center = center;\n    this.radius = radius;\n    this.color = \"#3daa4d\";\n    this.innerColorOpacity = .1; // in hex\n\n    this.borderWidth = 2;\n    this.angle = CONSTS.TWO_PI;\n\n    for (var objName in config) {\n      if (this[objName] == undefined) {\n        console.warn(Circle.name + \": \" + objName + \" parameter is undefined.\");\n      }\n\n      this[objName] = config[objName];\n    }\n\n    this.innerColorRGB = funcs.hexToRgb(this.color);\n    this.innerColorRGBa = \"rgba(\" + this.innerColorRGB[0] + \", \" + this.innerColorRGB[1] + \", \" + this.innerColorRGB[2] + \", \" + this.innerColorOpacity + \")\";\n    this.glowColorRGB = funcs.hexToRgb(this.color);\n    this.glowColorRGBa = \"rgba(\" + this.glowColorRGB[0] + \", \" + this.glowColorRGB[1] + \", \" + this.glowColorRGB[2] + \", \" + .25 + \")\";\n    this.type = \"Circle\";\n    this.shadowBlur = 0;\n    this.defaultShadowBlur = 8;\n    this.centerPx = new _Vector2__WEBPACK_IMPORTED_MODULE_2__[\"Vector2\"](); // this.selectionClock = new THREE.Clock();\n\n    this.pannable = true;\n  } // this method must be implemented in all Item class\n\n\n  _createClass(Circle, [{\n    key: \"setContext\",\n    value: function setContext(context, container) {\n      var _this = this;\n\n      this.context = context;\n      this.container = container;\n\n      if (this.context) {\n        // this.pos_px = this.container.getPixFromCoorPt(this.pos);\n        this.container.getPixFromCoorPtFT(this.center, this.centerPx);\n        this.radiusPx = this.radius / this.container.coorPerPixel;\n      } // animate scale... \n\n\n      this.originalAngle = this.angle;\n      this.angle = 0;\n      this.innerColorRGBa = \"rgba(\" + this.innerColorRGB[0] + \", \" + this.innerColorRGB[1] + \", \" + this.innerColorRGB[2] + \", \" + 0 + \")\";\n      var innerColorTween = new TWEEN.Tween({\n        opacity: 0\n      }).to({\n        opacity: this.innerColorOpacity\n      }, 200).easing(TWEEN.Easing.Quadratic.InOut).on('update', function (obj) {\n        _this.innerColorRGBa = \"rgba(\" + _this.innerColorRGB[0] + \", \" + _this.innerColorRGB[1] + \", \" + _this.innerColorRGB[2] + \", \" + obj.opacity + \")\";\n      });\n      new TWEEN.Tween({\n        angle: 0\n      }).to({\n        angle: this.originalAngle\n      }, 900).easing(TWEEN.Easing.Cubic.InOut).on('update', function (obj) {\n        _this.angle = obj.angle; // this.innerColorRGBa = \"rgba(\" + this.innerColorRGB[0] + \", \" + this.innerColorRGB[1] + \", \" + this.innerColorRGB[2] + \", \" + obj.opacity + \")\";\n      }).on(\"complete\", function () {\n        innerColorTween.start();\n      }).start();\n    } // this method must be implemented in all Item class\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      // this.context.shadowBlur = this.shadowBlur;\n      // this.context.shadowColor = this.color;\n      this.context.beginPath();\n      this.context.arc(this.centerPx.x, this.centerPx.y, this.radiusPx, 0, this.angle, false);\n      this.context.lineWidth = this.borderWidth;\n      this.context.strokeStyle = this.color;\n      this.context.stroke();\n      this.context.lineWidth = this.shadowBlur;\n      this.context.strokeStyle = this.glowColorRGBa;\n      this.context.stroke();\n      this.context.shadowBlur = 0;\n      this.context.fillStyle = this.innerColorRGBa;\n      this.context.fill();\n      this.context.beginPath();\n      this.context.arc(this.centerPx.x, this.centerPx.y, 3, 0, this.angle, false);\n      this.context.fillStyle = this.color;\n      this.context.fill();\n    }\n  }, {\n    key: \"updatePosCoor\",\n    value: function updatePosCoor(newCenter, newRadius) {\n      var _this2 = this;\n\n      var orginalValue = {\n        centerX: this.center.x,\n        centerY: this.center.y,\n        radius: this.radius\n      };\n      var toValue;\n\n      if (newRadius) {\n        toValue = {\n          centerX: newCenter.x,\n          centerY: newCenter.y,\n          radius: newRadius\n        };\n      } else {\n        toValue = {\n          centerX: newCenter.x,\n          centerY: newCenter.y,\n          radius: this.radius\n        };\n      }\n\n      new es6_tween__WEBPACK_IMPORTED_MODULE_1__[\"Tween\"](orginalValue).to(toValue, 800).easing(TWEEN.Easing.Quadratic.InOut).on('update', function (value) {\n        _this2.center.x = value.centerX;\n        _this2.center.y = value.centerY;\n        _this2.radius = value.radius;\n\n        _this2.updatePixelLocation();\n      }).start();\n    }\n  }, {\n    key: \"handleTap\",\n    value: function handleTap(tapped) {\n      if (tapped) {\n        this.select();\n      } else {\n        this.unselect();\n      }\n    }\n  }, {\n    key: \"handlePanStart\",\n    value: function handlePanStart(ptPx) {\n      console.log(\"pan start... \");\n    }\n  }, {\n    key: \"handlePanMove\",\n    value: function handlePanMove(ptPx) {\n      console.log(\"pan move..... \");\n    }\n  }, {\n    key: \"select\",\n    value: function select() {\n      var _this3 = this;\n\n      if (this.selected) {\n        this.unselect();\n        return;\n      }\n\n      new es6_tween__WEBPACK_IMPORTED_MODULE_1__[\"Tween\"]({\n        val: 0\n      }).to({\n        val: this.defaultShadowBlur\n      }, 300).easing(easings.selectionEasing).on('start', function () {\n        _this3.selected = true;\n      }).on('update', function (value) {\n        _this3.shadowBlur = value.val;\n      }).start();\n    }\n  }, {\n    key: \"unselect\",\n    value: function unselect() {\n      var _this4 = this;\n\n      new es6_tween__WEBPACK_IMPORTED_MODULE_1__[\"Tween\"]({\n        val: this.shadowBlur\n      }).to({\n        val: 0\n      }, 500).easing(TWEEN.Easing.Quartic.Out).on(\"start\", function () {\n        _this4.selected = false;\n      }).on('update', function (value) {\n        _this4.shadowBlur = value.val;\n      }).start();\n    }\n  }, {\n    key: \"animateSelectionEffect\",\n    value: function animateSelectionEffect() {\n      var _this5 = this;\n\n      this.shadowBlur = (Math.sin(10 * this.selectionClock.getElapsedTime()) + 1) * this.defaultShadowBlur;\n      this.selectionAniId = requestAnimationFrame(function () {\n        return _this5.animateSelectionEffect();\n      });\n    } // this method must be implemented in all Item class\n\n  }, {\n    key: \"updatePixelLocation\",\n    value: function updatePixelLocation() {\n      this.container.getPixFromCoorPtFT(this.center, this.centerPx);\n      this.radiusPx = this.radius / this.container.coorPerPixel;\n    } // this method must be implemented in all Item class\n\n  }, {\n    key: \"checkSelection\",\n    value: function checkSelection(ptPx) {\n      return funcs.getDistance(this.centerPx, ptPx) < this.radiusPx;\n    } // this method must be implemented in all Item classes\n\n  }, {\n    key: \"getBoundingBoxCoor\",\n    value: function getBoundingBoxCoor() {\n      return {\n        startX: this.center.x - this.radius.x,\n        startY: this.center.y + this.radius.y,\n        endX: this.center.x + this.radius.x,\n        endY: this.center.y - this.radius.y\n      };\n    }\n  }]);\n\n  return Circle;\n}();\n\n//# sourceURL=webpack://threeD/./src/v2_geometry/items/Circle.js?");

/***/ }),

/***/ "./src/v2_geometry/items/Line.js":
/*!***************************************!*\
  !*** ./src/v2_geometry/items/Line.js ***!
  \***************************************/
/*! exports provided: Line */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Line\", function() { return Line; });\n/* harmony import */ var es6_tween__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! es6-tween */ \"C:\\\\Users\\\\XiaoMi\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\es6-tween\\\\bundled\\\\Tween.min.js\");\n/* harmony import */ var es6_tween__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(es6_tween__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Vector2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Vector2 */ \"./src/v2_geometry/Vector2.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar CONSTS = __webpack_require__(/*! ../utils/constants */ \"./src/v2_geometry/utils/constants.js\");\n\nvar TWEEN = __webpack_require__(/*! es6-tween */ \"C:\\\\Users\\\\XiaoMi\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\es6-tween\\\\bundled\\\\Tween.min.js\");\n\n\n\n\nvar funcs = __webpack_require__(/*! ../utils/funcs */ \"./src/v2_geometry/utils/funcs.js\");\n\nObject(es6_tween__WEBPACK_IMPORTED_MODULE_0__[\"autoPlay\"])(true);\nvar Line = /*#__PURE__*/function () {\n  function Line(startPt, endPt, config) {\n    _classCallCheck(this, Line);\n\n    this.startPt = startPt;\n    this.endPt = endPt;\n    this.color = \"#000000\";\n    this.lineWidth = 2;\n    this.autoDraw = true; // start drawing once added to grid...\n\n    for (var objName in config) {\n      if (this[objName] == undefined) {\n        console.warn(Line.name + \": \" + objName + \" parameter is undefined.\");\n      }\n\n      this[objName] = config[objName];\n    }\n\n    this.startPtPx = new _Vector2__WEBPACK_IMPORTED_MODULE_1__[\"Vector2\"](0, 0);\n    this.endPtPx = new _Vector2__WEBPACK_IMPORTED_MODULE_1__[\"Vector2\"](0, 0);\n    this.type = \"Line\";\n  }\n\n  _createClass(Line, [{\n    key: \"setContext\",\n    value: function setContext(context, container) {\n      this.context = context;\n      this.container = container;\n      this.visible = this.autoDraw;\n\n      if (this.autoDraw) {\n        this.animateDraw();\n      } else {\n        this.visible = false;\n      }\n\n      this.updatePixelLocation();\n    }\n  }, {\n    key: \"animateDraw\",\n    value: function animateDraw() {\n      var _this = this;\n\n      var timeTakenTodraw = Math.pow(this.getLength(), 1 / 4.2) * 900;\n      var tempEndPt = this.endPt.clone();\n      this.endPt.copyFrom(this.startPt);\n      this.updatePixelLocation();\n      this.visible = true;\n      new es6_tween__WEBPACK_IMPORTED_MODULE_0__[\"Tween\"]({\n        x: this.startPt.x,\n        y: this.startPt.y\n      }).to({\n        x: tempEndPt.x,\n        y: tempEndPt.y\n      }, timeTakenTodraw).easing(TWEEN.Easing.Quadratic.InOut).on('update', function (value) {\n        _this.endPt.x = value.x;\n        _this.endPt.y = value.y;\n\n        _this.updatePixelLocation();\n\n        if (_this.drawCallback) {\n          _this.drawCallback(_this.endPt);\n        }\n      }).on(\"complete\", function () {\n        if (_this.finishCallback) {\n          _this.finishCallback();\n        }\n      }).start();\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(drawCallback, finishCallback) {\n      this.drawCallback = drawCallback;\n      this.finishCallback = finishCallback;\n      this.animateDraw();\n    }\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      return funcs.getDistance(this.startPt, this.endPt);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      if (!this.visible) return;\n      this.context.beginPath();\n      this.context.strokeStyle = this.color;\n      this.context.lineWidth = this.lineWidth;\n      this.context.lineCap = 'round';\n      this.context.moveTo(this.startPtPx.x, this.startPtPx.y);\n      this.context.lineTo(this.endPtPx.x, this.endPtPx.y);\n      this.context.stroke();\n    } // this method must be implemented in all Item class\n\n  }, {\n    key: \"updatePixelLocation\",\n    value: function updatePixelLocation() {\n      this.container.getPixFromCoorPtFT(this.startPt, this.startPtPx);\n      this.container.getPixFromCoorPtFT(this.endPt, this.endPtPx);\n    } // this method must be implemented in all Item classes\n\n  }, {\n    key: \"getBoundingBoxCoor\",\n    value: function getBoundingBoxCoor() {}\n  }]);\n\n  return Line;\n}();\n\n//# sourceURL=webpack://threeD/./src/v2_geometry/items/Line.js?");

/***/ }),

/***/ "./src/v2_geometry/items/Point.js":
/*!****************************************!*\
  !*** ./src/v2_geometry/items/Point.js ***!
  \****************************************/
/*! exports provided: Point */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Point\", function() { return Point; });\n/* harmony import */ var es6_tween__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! es6-tween */ \"C:\\\\Users\\\\XiaoMi\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\es6-tween\\\\bundled\\\\Tween.min.js\");\n/* harmony import */ var es6_tween__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(es6_tween__WEBPACK_IMPORTED_MODULE_0__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar CONSTS = __webpack_require__(/*! ../utils/constants */ \"./src/v2_geometry/utils/constants.js\");\n\nvar TWEEN = __webpack_require__(/*! es6-tween */ \"C:\\\\Users\\\\XiaoMi\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\es6-tween\\\\bundled\\\\Tween.min.js\");\n\n\n\nvar funcs = __webpack_require__(/*! ../utils/funcs */ \"./src/v2_geometry/utils/funcs.js\");\n\nObject(es6_tween__WEBPACK_IMPORTED_MODULE_0__[\"autoPlay\"])(true);\nvar Point = /*#__PURE__*/function () {\n  function Point(pos, config) {\n    _classCallCheck(this, Point);\n\n    this.type = \"Point\";\n    this.pos = pos;\n    this.posPx = {}; // please also update \"borderColor\"\n\n    this.color = \"#000000\";\n    this.borderColor = this.color + \"55\"; // if size is updated, borderSize must also be updated\n\n    this.size = 4; // radius\n\n    this.selected = true;\n\n    for (var objName in config) {\n      if (this[objName] == undefined) {\n        console.warn(Point.name + \": \" + objName + \" parameter is undefined.\");\n      }\n\n      this[objName] = config[objName];\n    }\n\n    this.borderColor = this.color + \"55\";\n    this.borderSize = this.size * 3;\n    this.defaultSize = this.size;\n  } // this method must be implemented in all Item class\n\n\n  _createClass(Point, [{\n    key: \"setContext\",\n    value: function setContext(context, container) {\n      var _this = this;\n\n      this.context = context;\n      this.container = container;\n\n      if (this.context) {\n        this.container.getPixFromCoorPtFT(this.pos, this.posPx);\n      } // animate scale... \n\n\n      this.borderSize = 0;\n      new es6_tween__WEBPACK_IMPORTED_MODULE_0__[\"Tween\"]({\n        size: 0\n      }).to({\n        size: this.defaultSize\n      }, 1000).easing(TWEEN.Easing.Elastic.Out).on('update', function (obj) {\n        _this.size = obj.size;\n        _this.borderSize = obj.size * 3;\n      }).start();\n    } // this method must be implemented in all Item class\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.context.beginPath();\n      this.context.arc(this.posPx.x, this.posPx.y, this.size, 0, CONSTS.TWO_PI, false);\n      this.context.fillStyle = this.color;\n      this.context.fill();\n\n      if (this.selected) {\n        this.context.lineWidth = this.borderSize;\n        this.context.strokeStyle = this.borderColor;\n        this.context.stroke();\n      }\n    }\n  }, {\n    key: \"handleTap\",\n    value: function handleTap(tapped) {\n      var _this2 = this;\n\n      if (tapped) {\n        new es6_tween__WEBPACK_IMPORTED_MODULE_0__[\"Tween\"]({\n          size: 0\n        }).to({\n          size: this.defaultSize\n        }, 1000).easing(TWEEN.Easing.Elastic.Out).on('update', function (obj) {\n          _this2.size = obj.size;\n          _this2.borderSize = obj.size * 3;\n        }).start();\n      } else {}\n    }\n  }, {\n    key: \"updatePosCoor\",\n    value: function updatePosCoor(pos) {\n      var _this3 = this;\n\n      new es6_tween__WEBPACK_IMPORTED_MODULE_0__[\"Tween\"](this.pos).to(pos, 1000).easing(TWEEN.Easing.Linear.None).on('update', function (pt) {\n        _this3.container.getPixFromCoorPtFT(pt, _this3.posPx);\n      }).start();\n    } // this method must be implemented in all Item classes\n\n  }, {\n    key: \"updatePixelLocation\",\n    value: function updatePixelLocation() {\n      this.container.getPixFromCoorPtFT(this.pos, this.posPx);\n    } //this method must be implemented in all Item class\n\n  }, {\n    key: \"checkSelection\",\n    value: function checkSelection(ptPx) {\n      return funcs.getDistance(this.posPx, ptPx) < this.borderSize + 5;\n    } // this method must be implemented in all Item classes\n\n  }, {\n    key: \"getBoundingBoxCoor\",\n    value: function getBoundingBoxCoor() {\n      return {\n        startX: this.pos.x,\n        startY: this.pos.y,\n        endX: this.pos.x,\n        endY: this.pos.y\n      };\n    }\n  }]);\n\n  return Point;\n}();\n\n//# sourceURL=webpack://threeD/./src/v2_geometry/items/Point.js?");

/***/ }),

/***/ "./src/v2_geometry/items/Triangle.js":
/*!*******************************************!*\
  !*** ./src/v2_geometry/items/Triangle.js ***!
  \*******************************************/
/*! exports provided: Triangle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Triangle\", function() { return Triangle; });\n/* harmony import */ var es6_tween__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! es6-tween */ \"C:\\\\Users\\\\XiaoMi\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\es6-tween\\\\bundled\\\\Tween.min.js\");\n/* harmony import */ var es6_tween__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(es6_tween__WEBPACK_IMPORTED_MODULE_0__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar CONSTS = __webpack_require__(/*! ../utils/constants */ \"./src/v2_geometry/utils/constants.js\");\n\nvar TWEEN = __webpack_require__(/*! es6-tween */ \"C:\\\\Users\\\\XiaoMi\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\es6-tween\\\\bundled\\\\Tween.min.js\");\n\nvar funcs = __webpack_require__(/*! ../utils/funcs */ \"./src/v2_geometry/utils/funcs.js\");\n\n\nObject(es6_tween__WEBPACK_IMPORTED_MODULE_0__[\"autoPlay\"])(true);\nvar Triangle = /*#__PURE__*/function () {\n  function Triangle(pt1, pt2, pt3, config) {\n    _classCallCheck(this, Triangle);\n\n    this.color = \"#ff0000\";\n    this.innerColorOpacity = .15; // in hex\n\n    this.borderWidth = 2.5;\n\n    this.completeCallback = function () {};\n\n    for (var objName in config) {\n      if (this[objName] == undefined) {\n        console.warn(Triangle.name + \": \" + objName + \" parameter is undefined.\");\n      }\n\n      this[objName] = config[objName];\n    }\n\n    this.innerColorRGB = funcs.hexToRgb(this.color);\n    this.innerColorRGBa = \"rgba(\" + this.innerColorRGB[0] + \", \" + this.innerColorRGB[1] + \", \" + this.innerColorRGB[2] + \", \" + this.innerColorOpacity + \")\";\n    this.vertexArr = [pt1, pt2, pt3];\n    this.type = \"Triangle\";\n    this.completeConstruction = false;\n    this.attachedItems = [];\n  }\n\n  _createClass(Triangle, [{\n    key: \"setContext\",\n    value: function setContext(context, container) {\n      var _this = this;\n\n      this.context = context;\n      this.container = container;\n      this.vertexArrPx = [this.container.getPixFromCoorPt(this.vertexArr[0]), this.container.getPixFromCoorPt(this.vertexArr[1]), this.container.getPixFromCoorPt(this.vertexArr[2])];\n      this.currentVtxIdx = 0;\n      this.currentSegmentsLength = 0;\n      this.vertexArrPx.length = 0;\n      this.totalSideLength = funcs.getLengthOfPath(this.vertexArr);\n      this.vertexArrPx[0] = this.container.getPixFromCoorPt(this.vertexArr[0]);\n      this.endPointPx = this.container.getPixFromCoorPt(this.vertexArr[0]);\n      var originalValue = {\n        len: 0\n      };\n      var edgeTween = new es6_tween__WEBPACK_IMPORTED_MODULE_0__[\"Tween\"](originalValue).to({\n        len: this.totalSideLength\n      }, 1800).easing(TWEEN.Easing.Sinusoidal.InOut).on('update', function (value) {\n        _this.getVerticesToDraw(value.len);\n      }).on('complete', function (value) {\n        _this.container.getPixFromCoorPtFT(_this.vertexArr[0], _this.endPointPx);\n\n        _this.completeConstruction = true;\n        innerColorTween.start();\n      });\n      var currentValInnerColor = {\n        opacity: 0\n      };\n      this.innerColorRGBa = \"rgba(\" + this.innerColorRGB[0] + \", \" + this.innerColorRGB[1] + \", \" + this.innerColorRGB[2] + \", \" + 0 + \")\";\n      var innerColorTween = new TWEEN.Tween(currentValInnerColor).to({\n        opacity: this.innerColorOpacity\n      }, 200).easing(TWEEN.Easing.Quadratic.InOut).on('update', function (obj) {\n        _this.innerColorRGBa = \"rgba(\" + _this.innerColorRGB[0] + \", \" + _this.innerColorRGB[1] + \", \" + _this.innerColorRGB[2] + \", \" + obj.opacity + \")\";\n      }).on(\"complete\", function () {\n        if (_this.completeCallback) {\n          _this.completeCallback();\n        }\n      });\n      edgeTween.start();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.context.beginPath();\n      this.context.strokeStyle = this.color;\n      this.context.lineWidth = this.borderWidth;\n      this.context.lineJoin = 'round';\n      this.context.fillStyle = this.innerColorRGBa;\n      this.context.moveTo(this.vertexArrPx[0].x, this.vertexArrPx[0].y);\n\n      for (var i = 1; i < this.vertexArrPx.length; i++) {\n        this.context.lineTo(this.vertexArrPx[i].x, this.vertexArrPx[i].y);\n      }\n\n      if (this.completeConstruction) {\n        this.context.closePath();\n      } else {\n        this.context.lineTo(this.endPointPx.x, this.endPointPx.y);\n      }\n\n      this.context.stroke();\n      this.context.fill();\n    } // this method must be implemented in all Item classes\n\n  }, {\n    key: \"updatePixelLocation\",\n    value: function updatePixelLocation() {\n      for (var i = 0; i < this.vertexArrPx.length; i++) {\n        this.container.getPixFromCoorPtFT(this.vertexArr[i], this.vertexArrPx[i]);\n      }\n\n      this.container.getPixFromCoorPtFT(this.vertexArr[0], this.endPointPx);\n    }\n  }, {\n    key: \"geometryChanged\",\n    value: function geometryChanged() {\n      for (var i = 0; i < this.attachedItems.length; i++) {\n        this.attachedItems[i].parentGeometryChanged();\n      }\n    } // this method must be implemented in all Item classes\n\n  }, {\n    key: \"getBoundingBoxCoor\",\n    value: function getBoundingBoxCoor() {\n      return {};\n    } // construction animation codes..\n\n  }, {\n    key: \"getVerticesToDraw\",\n    value: function getVerticesToDraw(currentLength) {\n      for (var i = this.currentVtxIdx; i < this.vertexArr.length; i++) {\n        var segmentLen = void 0;\n        segmentLen = this.currentSegmentsLength + funcs.getDistance(this.vertexArr[i], this.vertexArr[(i + 1) % this.vertexArr.length]); // console.log(\"this.currentSegmentsLength \" + this.currentSegmentsLength)\n\n        if (currentLength < segmentLen) {\n          var vectorLen = currentLength - this.currentSegmentsLength;\n          var vector = {\n            x: this.vertexArr[(i + 1) % this.vertexArr.length].x - this.vertexArr[i].x,\n            y: this.vertexArr[(i + 1) % this.vertexArr.length].y - this.vertexArr[i].y\n          };\n          var norm = funcs.getNorm(vector);\n          this.container.getPixFromCoorPtFT({\n            x: this.vertexArr[i].x + vector.x / norm * vectorLen,\n            y: this.vertexArr[i].y + vector.y / norm * vectorLen\n          }, this.endPointPx);\n          break;\n        } else {\n          if (i != this.vertexArr.length - 1) {\n            this.currentSegmentsLength += funcs.getDistance(this.vertexArr[i], this.vertexArr[i + 1]);\n            this.vertexArrPx.push(this.container.getPixFromCoorPt(this.vertexArr[i + 1]));\n            this.currentVtxIdx++;\n          }\n        }\n      }\n    }\n  }]);\n\n  return Triangle;\n}();\n\n//# sourceURL=webpack://threeD/./src/v2_geometry/items/Triangle.js?");

/***/ }),

/***/ "./src/v2_geometry/items/Vector.js":
/*!*****************************************!*\
  !*** ./src/v2_geometry/items/Vector.js ***!
  \*****************************************/
/*! exports provided: Vector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vector\", function() { return Vector; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar CONSTS = __webpack_require__(/*! ../utils/constants */ \"./src/v2_geometry/utils/constants.js\");\n\nvar TWEEN = __webpack_require__(/*! es6-tween */ \"C:\\\\Users\\\\XiaoMi\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\es6-tween\\\\bundled\\\\Tween.min.js\");\n\nvar funcs = __webpack_require__(/*! ../utils/funcs */ \"./src/v2_geometry/utils/funcs.js\"); // import { Tween, autoPlay } from 'es6-tween';\n// autoPlay(true);\n\n\nvar Vector = /*#__PURE__*/function () {\n  function Vector(pos, direction, config) {\n    _classCallCheck(this, Vector);\n\n    this.pos = pos;\n    this.direction = direction;\n    this.color = \"#ff3300\";\n    this.lineWidth = 2;\n\n    for (var objName in config) {\n      if (this[objName] == undefined) {\n        console.warn(Vector.name + \": \" + objName + \" parameter is undefined.\");\n      }\n\n      this[objName] = config[objName];\n    }\n\n    this.posPx = {};\n    this.posTipPx = {};\n    this.headBaseLeftPx = {};\n    this.headBaseRightPx = {};\n    this.neckLocationPx = {};\n    this.type = \"Vector\";\n    this.calculatePoints();\n  } // this method must be implemented in all Item class\n\n\n  _createClass(Vector, [{\n    key: \"setContext\",\n    value: function setContext(context, container) {\n      this.context = context;\n      this.container = container;\n      this.updatePixelLocation();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.context.beginPath();\n      this.context.lineWidth = this.lineWidth;\n      this.context.strokeStyle = this.color;\n      this.context.fillStyle = this.color;\n      this.context.moveTo(this.posPx.x, this.posPx.y);\n      this.context.lineTo(this.posTipPx.x, this.posTipPx.y);\n      this.context.stroke();\n      this.context.lineJoin = 'miter';\n      this.context.beginPath();\n      this.context.moveTo(this.posTipPx.x, this.posTipPx.y);\n      this.context.lineTo(this.headBaseLeftPx.x, this.headBaseLeftPx.y);\n      this.context.lineTo(this.headBaseRightPx.x, this.headBaseRightPx.y);\n      this.context.closePath();\n      this.context.stroke();\n      this.context.fill();\n    }\n  }, {\n    key: \"calculatePoints\",\n    value: function calculatePoints() {\n      this.normalVector = {\n        x: -this.direction.y,\n        y: this.direction.x\n      };\n      this.normalUnitVector = funcs.getUnitVector(this.normalVector);\n      this.unitVector = funcs.getUnitVector(this.direction); // this.neckLocation = {x : this.unitVector.x * 10, y : this.unitVector.y * 10};\n\n      this.neckLeftVector = {\n        x: this.normalUnitVector.x * 5,\n        y: this.normalUnitVector.y * -5\n      };\n      this.neckVectorPx = {\n        x: this.unitVector.x * -14,\n        y: this.unitVector.y * 14\n      };\n    }\n  }, {\n    key: \"update\",\n    value: function update(pos, direction) {\n      this.pos = pos;\n      this.direction = direction;\n      this.calculatePoints();\n      this.updatePixelLocation();\n    } // this method must be implemented in all Item class\n\n  }, {\n    key: \"updatePixelLocation\",\n    value: function updatePixelLocation() {\n      this.container.getPixFromCoorPtFT(this.pos, this.posPx);\n      this.container.getPixFromCoorPtFT({\n        x: this.pos.x + this.direction.x,\n        y: this.pos.y + this.direction.y\n      }, this.posTipPx);\n      this.neckLocationPx.x = this.posTipPx.x + this.neckVectorPx.x;\n      this.neckLocationPx.y = this.posTipPx.y + this.neckVectorPx.y;\n      this.headBaseLeftPx.x = this.neckLocationPx.x + this.neckLeftVector.x;\n      this.headBaseLeftPx.y = this.neckLocationPx.y + this.neckLeftVector.y;\n      this.headBaseRightPx.x = this.neckLocationPx.x - this.neckLeftVector.x;\n      this.headBaseRightPx.y = this.neckLocationPx.y - this.neckLeftVector.y;\n    } // this method must be implemented in all Item classes\n\n  }, {\n    key: \"getBoundingBoxCoor\",\n    value: function getBoundingBoxCoor() {}\n  }]);\n\n  return Vector;\n}();\n\n//# sourceURL=webpack://threeD/./src/v2_geometry/items/Vector.js?");

/***/ }),

/***/ "./src/v2_geometry/items/mesurements/Angle.js":
/*!****************************************************!*\
  !*** ./src/v2_geometry/items/mesurements/Angle.js ***!
  \****************************************************/
/*! exports provided: Angle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Angle\", function() { return Angle; });\n/* harmony import */ var es6_tween__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! es6-tween */ \"C:\\\\Users\\\\XiaoMi\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\es6-tween\\\\bundled\\\\Tween.min.js\");\n/* harmony import */ var es6_tween__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(es6_tween__WEBPACK_IMPORTED_MODULE_0__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar CONSTS = __webpack_require__(/*! ../../utils/constants */ \"./src/v2_geometry/utils/constants.js\");\n\nvar TWEEN = __webpack_require__(/*! es6-tween */ \"C:\\\\Users\\\\XiaoMi\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\es6-tween\\\\bundled\\\\Tween.min.js\");\n\nvar funcs = __webpack_require__(/*! ../../utils/funcs */ \"./src/v2_geometry/utils/funcs.js\");\n\n\nObject(es6_tween__WEBPACK_IMPORTED_MODULE_0__[\"autoPlay\"])(true);\nvar Angle = /*#__PURE__*/function () {\n  function Angle(line1Start, line1End, line2Start, line2End, config) {\n    _classCallCheck(this, Angle);\n\n    this.line1Start = line1Start;\n    this.line1End = line1End;\n    this.line2Start = line2Start;\n    this.line2End = line2End;\n    this.defaultArcRadius = 33;\n    this.defaultFontSize = 12;\n    this.arcRadius = this.defaultArcRadius;\n    this.fontSize = \"bold \" + this.defaultFontSize + 'pt Computer Modern';\n    this.borderWidth = 2;\n    this.color = \"#444444\";\n    this.textColor = \"#333333\";\n    this.thresholdSide = this.arcRadius / CONSTS.TAN_PI_BY_12;\n    this.slopeForFontSize = this.defaultFontSize / this.thresholdSide;\n    this.locLabel = {};\n    this.commonPtPx = {};\n\n    this.completeCallback = function () {};\n\n    for (var objName in config) {\n      if (this[objName] == undefined) {\n        console.warn(Angle.name + \": \" + objName + \" parameter is undefined.\");\n      }\n\n      this[objName] = config[objName];\n    }\n\n    this.textColorArr = funcs.hexToRgb(this.textColor);\n    this.textColor = \"rgba(\" + this.textColorArr[0] + \", \" + this.textColorArr[1] + \", \" + this.textColorArr[2] + \", \" + 1 + \")\";\n    this.textStrokeColor = \"rgba(\" + this.textColorArr[0] + \", \" + this.textColorArr[1] + \", \" + this.textColorArr[2] + \", \" + 1 + \")\";\n    this.type = \"Angle\";\n  }\n\n  _createClass(Angle, [{\n    key: \"setContext\",\n    value: function setContext(context, container) {\n      var _this = this;\n\n      this.context = context;\n      this.container = container;\n      this.updateAngle();\n      this.updatePixelLocation();\n      this.adjustScale();\n      this.tempAngle2 = this.angle2;\n      this.angle2 = this.angle1; // let originalValueTween1 = ;\n\n      var originalValueTween2 = {\n        opacity: 0\n      };\n      this.textColor = \"rgba(\" + this.textColorArr[0] + \", \" + this.textColorArr[1] + \", \" + this.textColorArr[2] + \", \" + 0 + \")\";\n      this.textStrokeColor = \"rgba(255, 255, 255, 0)\";\n      var tween1 = new es6_tween__WEBPACK_IMPORTED_MODULE_0__[\"Tween\"]({\n        angle: this.angle1\n      }).to({\n        angle: this.tempAngle2,\n        opacity: 1\n      }, 700).easing(TWEEN.Easing.Sinusoidal.InOut).delay(150).on('update', function (value) {\n        _this.angle2 = value.angle;\n      }).on(\"complete\", function () {\n        tween2.start();\n      });\n      var tween2 = new es6_tween__WEBPACK_IMPORTED_MODULE_0__[\"Tween\"](originalValueTween2).to({\n        opacity: 1\n      }, 900).easing(TWEEN.Easing.Sinusoidal.InOut).on('update', function (value) {\n        _this.textColor = \"rgba(\" + _this.textColorArr[0] + \", \" + _this.textColorArr[1] + \", \" + _this.textColorArr[2] + \", \" + value.opacity + \")\";\n        _this.textStrokeColor = \"rgba(255, 255, 255, \" + value.opacity * .8 + \")\";\n      }).delay(100).on(\"complete\", function () {\n        if (_this.completeCallback) {\n          _this.completeCallback();\n        }\n      });\n      tween1.start();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      if (this.line1End.x != this.line2Start.x || this.line1End.y != this.line2Start.y) {\n        return;\n      }\n\n      this.context.beginPath();\n      this.context.lineWidth = this.borderWidth;\n      this.context.strokeStyle = this.color;\n      this.context.font = this.fontSize;\n      this.context.arc(this.commonPtPx.x, this.commonPtPx.y, this.arcRadius, this.angle1, this.angle2, false); // line color\n\n      this.context.stroke();\n      this.context.textAlign = 'center';\n      this.context.lineWidth = 4;\n      this.context.strokeStyle = this.textStrokeColor;\n      this.context.strokeText(this.angleText, this.commonPtPx.x + this.locLabel.x, this.commonPtPx.y + this.locLabel.y);\n      this.context.fillStyle = this.textColor;\n      this.context.fillText(this.angleText, this.commonPtPx.x + this.locLabel.x, this.commonPtPx.y + this.locLabel.y);\n    }\n  }, {\n    key: \"updateAngle\",\n    value: function updateAngle() {\n      this.vector1 = {\n        x: this.line1Start.x - this.line1End.x,\n        y: this.line1Start.y - this.line1End.y\n      };\n      this.vector2 = {\n        x: this.line2End.x - this.line2Start.x,\n        y: this.line2End.y - this.line2Start.y\n      };\n      this.angle1 = funcs.getAngle(this.vector1);\n      this.angle2 = funcs.getAngle(this.vector2);\n\n      if (this.angle2 < this.angle1) {\n        this.angle2 += CONSTS.TWO_PI;\n      }\n\n      this.angle = this.angle2 - this.angle1;\n      this.angleText = (this.angle * 180 / Math.PI).toFixed(1) + \"\";\n      this.labelAngle = (this.angle1 + this.angle / 2) % CONSTS.TWO_PI;\n    } // this method must be implemented in all Item classes\n\n  }, {\n    key: \"updatePixelLocation\",\n    value: function updatePixelLocation() {\n      this.container.getPixFromCoorPtFT(this.line1End, this.commonPtPx);\n    } //  \n\n  }, {\n    key: \"adjustScale\",\n    value: function adjustScale() {\n      // adjust radius\n      var minLength = Math.min(funcs.getDistance(this.container.getPixFromCoorPt(this.line1Start), this.container.getPixFromCoorPt(this.line1End)), funcs.getDistance(this.container.getPixFromCoorPt(this.line2Start), this.container.getPixFromCoorPt(this.line2End)));\n\n      if (minLength < this.thresholdSide) {\n        this.arcRadius = minLength * CONSTS.TAN_PI_BY_12; // this.fontSize = (minLength * this.slopeForFontSize) + 'pt Calibri';\n      } else {\n        this.arcRadius = this.defaultArcRadius; // this.fontSize = this.defaultFontSize + 'pt Calibri';            \n      }\n\n      this.locLabel = funcs.getXYFromTheta(this.labelAngle, this.arcRadius + 27, this.arcRadius + 14);\n      this.locLabel.y += this.defaultFontSize / 3;\n    }\n  }]);\n\n  return Angle;\n}();\n\n//# sourceURL=webpack://threeD/./src/v2_geometry/items/mesurements/Angle.js?");

/***/ }),

/***/ "./src/v2_geometry/staticItems/Clock.js":
/*!**********************************************!*\
  !*** ./src/v2_geometry/staticItems/Clock.js ***!
  \**********************************************/
/*! exports provided: Clock */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Clock\", function() { return Clock; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar CONSTS = __webpack_require__(/*! ../utils/constants */ \"./src/v2_geometry/utils/constants.js\");\n\nvar Clock = /*#__PURE__*/function () {\n  function Clock() {\n    _classCallCheck(this, Clock);\n\n    this.pos = {\n      x: 100,\n      y: 30\n    };\n    this.itemSize = \"Large\";\n  }\n\n  _createClass(Clock, [{\n    key: \"render\",\n    value: function render() {\n      var now = new Date();\n      this.context.save(); // this.context.clearRect(0, 0, 150, 150);\n\n      this.context.translate(150, 150); // this.context.scale(0.4, 0.4);\n\n      this.context.rotate(-Math.PI / 2);\n      this.context.strokeStyle = 'black';\n      this.context.fillStyle = 'white';\n      this.context.lineWidth = 8;\n      this.context.lineCap = 'round'; // Hour marks\n\n      this.context.save();\n\n      for (var i = 0; i < 12; i++) {\n        this.context.beginPath();\n        this.context.rotate(Math.PI / 6);\n        this.context.moveTo(100, 0);\n        this.context.lineTo(120, 0);\n        this.context.stroke();\n      }\n\n      this.context.restore(); // Minute marks\n\n      this.context.save();\n      this.context.lineWidth = 5;\n\n      for (i = 0; i < 60; i++) {\n        if (i % 5 != 0) {\n          this.context.beginPath();\n          this.context.moveTo(117, 0);\n          this.context.lineTo(120, 0);\n          this.context.stroke();\n        }\n\n        this.context.rotate(Math.PI / 30);\n      }\n\n      this.context.restore();\n      var sec = now.getSeconds();\n      var min = now.getMinutes();\n      var hr = now.getHours();\n      hr = hr >= 12 ? hr - 12 : hr;\n      this.context.fillStyle = 'black'; // write Hours\n\n      this.context.save();\n      this.context.rotate(hr * (Math.PI / 6) + Math.PI / 360 * min + Math.PI / 21600 * sec);\n      this.context.lineWidth = 14;\n      this.context.beginPath();\n      this.context.moveTo(-20, 0);\n      this.context.lineTo(80, 0);\n      this.context.stroke();\n      this.context.restore(); // write Minutes\n\n      this.context.save();\n      this.context.rotate(Math.PI / 30 * min + Math.PI / 1800 * sec);\n      this.context.lineWidth = 10;\n      this.context.beginPath();\n      this.context.moveTo(-28, 0);\n      this.context.lineTo(112, 0);\n      this.context.stroke();\n      this.context.restore(); // Write seconds\n\n      this.context.save();\n      this.context.rotate(sec * Math.PI / 30);\n      this.context.strokeStyle = '#D40000';\n      this.context.fillStyle = '#D40000';\n      this.context.lineWidth = 6;\n      this.context.beginPath();\n      this.context.moveTo(-30, 0);\n      this.context.lineTo(83, 0);\n      this.context.stroke();\n      this.context.beginPath();\n      this.context.arc(0, 0, 10, 0, Math.PI * 2, true);\n      this.context.fill();\n      this.context.beginPath();\n      this.context.arc(95, 0, 10, 0, Math.PI * 2, true);\n      this.context.stroke();\n      this.context.fillStyle = 'rgba(0, 0, 0, 0)';\n      this.context.arc(0, 0, 3, 0, Math.PI * 2, true);\n      this.context.fill();\n      this.context.restore();\n      this.context.beginPath();\n      this.context.lineWidth = 14;\n      this.context.strokeStyle = '#325FA2';\n      this.context.arc(0, 0, 142, 0, Math.PI * 2, true);\n      this.context.stroke();\n      this.context.restore();\n    }\n  }, {\n    key: \"setContext\",\n    value: function setContext(context, container) {\n      this.context = context;\n      this.container = container;\n\n      if (this.context) {\n        this.pos_px = this.container.getPixFromCoorPt(this.pos);\n      }\n    }\n  }]);\n\n  return Clock;\n}();\n\n//# sourceURL=webpack://threeD/./src/v2_geometry/staticItems/Clock.js?");

/***/ }),

/***/ "./src/v2_geometry/utils/Clock.js":
/*!****************************************!*\
  !*** ./src/v2_geometry/utils/Clock.js ***!
  \****************************************/
/*! exports provided: Clock */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Clock\", function() { return Clock; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Clock = /*#__PURE__*/function () {\n  function Clock(autoStart) {\n    _classCallCheck(this, Clock);\n\n    this.autoStart = autoStart !== undefined ? autoStart : true;\n    this.startTime = 0;\n    this.oldTime = 0;\n    this.elapsedTime = 0;\n    this.running = false;\n  }\n\n  _createClass(Clock, [{\n    key: \"start\",\n    value: function start() {\n      this.startTime = (typeof performance === 'undefined' ? Date : performance).now(); // see #10732\n\n      this.oldTime = this.startTime;\n      this.elapsedTime = 0;\n      this.running = true;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.getElapsedTime();\n      this.running = false;\n      this.autoStart = false;\n    }\n  }, {\n    key: \"getElapsedTime\",\n    value: function getElapsedTime() {\n      this.getDelta();\n      return this.elapsedTime;\n    }\n  }, {\n    key: \"getDelta\",\n    value: function getDelta() {\n      var diff = 0;\n\n      if (this.autoStart && !this.running) {\n        this.start();\n        return 0;\n      }\n\n      if (this.running) {\n        var newTime = (typeof performance === 'undefined' ? Date : performance).now();\n        diff = (newTime - this.oldTime) / 1000;\n        this.oldTime = newTime;\n        this.elapsedTime += diff;\n      }\n\n      return diff;\n    }\n  }]);\n\n  return Clock;\n}();\n\n//# sourceURL=webpack://threeD/./src/v2_geometry/utils/Clock.js?");

/***/ }),

/***/ "./src/v2_geometry/utils/constants.js":
/*!********************************************!*\
  !*** ./src/v2_geometry/utils/constants.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var TWO_PI = Math.PI * 2;\nvar PI_BY_2 = Math.PI / 2;\nvar THREE_PI_BY_2 = Math.PI * 3 / 2;\nvar TAN_PI_BY_12 = Math.tan(Math.PI / 12);\nmodule.exports = {\n  TWO_PI: TWO_PI,\n  TAN_PI_BY_12: TAN_PI_BY_12,\n  PI_BY_2: PI_BY_2,\n  THREE_PI_BY_2: THREE_PI_BY_2\n};\n\n//# sourceURL=webpack://threeD/./src/v2_geometry/utils/constants.js?");

/***/ }),

/***/ "./src/v2_geometry/utils/easings.js":
/*!******************************************!*\
  !*** ./src/v2_geometry/utils/easings.js ***!
  \******************************************/
/*! exports provided: selectionEasing */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"selectionEasing\", function() { return selectionEasing; });\nfunction selectionEasing(t) {\n  var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var ts = (t /= d) * t;\n  var tc = ts * t;\n  return b + c * (5.95 * tc * ts + 8.045 * ts * ts + -31.99 * tc + 18.995 * ts);\n}\n\n//# sourceURL=webpack://threeD/./src/v2_geometry/utils/easings.js?");

/***/ }),

/***/ "./src/v2_geometry/utils/funcs.js":
/*!****************************************!*\
  !*** ./src/v2_geometry/utils/funcs.js ***!
  \****************************************/
/*! exports provided: hexToRgb, getLengthOfPath, getDistance, getNorm, getUnitVector, getUnitVectorInplace, getAngleCC, getAngle, getXYFromTheta, getAngleFrom3Points */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hexToRgb\", function() { return hexToRgb; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getLengthOfPath\", function() { return getLengthOfPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDistance\", function() { return getDistance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getNorm\", function() { return getNorm; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getUnitVector\", function() { return getUnitVector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getUnitVectorInplace\", function() { return getUnitVectorInplace; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAngleCC\", function() { return getAngleCC; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAngle\", function() { return getAngle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getXYFromTheta\", function() { return getXYFromTheta; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAngleFrom3Points\", function() { return getAngleFrom3Points; });\nvar CONSTS = __webpack_require__(/*! ./constants */ \"./src/v2_geometry/utils/constants.js\");\n\nvar hexToRgb = function hexToRgb(hex) {\n  return hex.replace(/^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i, function (m, r, g, b) {\n    return '#' + r + r + g + g + b + b;\n  }).substring(1).match(/.{2}/g).map(function (x) {\n    return parseInt(x, 16);\n  });\n};\nfunction getLengthOfPath(vertexArr) {\n  var length = 0;\n\n  for (var i = 0; i < vertexArr.length; i++) {\n    length += Math.sqrt(Math.pow(vertexArr[i].x - vertexArr[(i + 1) % vertexArr.length].x, 2) + Math.pow(vertexArr[i].y - vertexArr[(i + 1) % vertexArr.length].y, 2));\n  }\n\n  return length;\n}\nfunction getDistance(pt1, pt2) {\n  return Math.sqrt(Math.pow(pt1.x - pt2.x, 2) + Math.pow(pt1.y - pt2.y, 2));\n}\nfunction getNorm(vector) {\n  return Math.sqrt(Math.pow(vector.x, 2) + Math.pow(vector.y, 2));\n}\nfunction getUnitVector(vector) {\n  var norm = Math.sqrt(Math.pow(vector.x, 2) + Math.pow(vector.y, 2));\n  return {\n    x: vector.x / norm,\n    y: vector.y / norm\n  };\n}\nfunction getUnitVectorInplace(vector, toVector) {\n  var norm = Math.sqrt(Math.pow(vector.x, 2) + Math.pow(vector.y, 2));\n  toVector.x = vector.x / norm;\n  toVector.y = vector.y / norm;\n}\nfunction getAngleCC(pt) {\n  // counter- clockwise\n  var angle = Math.atan2(pt.y, pt.x);\n\n  if (angle < 0) {\n    return CONSTS.TWO_PI + angle;\n  }\n\n  return angle;\n}\nfunction getAngle(pt) {\n  // clockwise\n  var angle = Math.atan2(pt.y, pt.x);\n\n  if (angle < 0) {\n    return -angle;\n  } else {\n    return CONSTS.TWO_PI - angle;\n  }\n} // get (x, y) position of ellipse from theta\n\nfunction getXYFromTheta(, a, b) {\n  return {\n    x: a * Math.cos(),\n    y: b * Math.sin()\n  };\n} // \n\nfunction getAngleFrom3Points(pt1, pt2, pt3) {\n  this.angle1 = getAngle({\n    x: pt1.x - pt2.x,\n    y: pt1.y - pt2.y\n  });\n  this.angle2 = getAngle({\n    x: pt3.x - pt2.x,\n    y: pt3.y - pt2.y\n  });\n\n  if (this.angle2 < this.angle1) {\n    this.angle = CONSTS.TWO_PI + this.angle2 - this.angle1;\n  } else {\n    this.angle = this.angle2 - this.angle1;\n  }\n\n  return this.angle;\n}\n\n//# sourceURL=webpack://threeD/./src/v2_geometry/utils/funcs.js?");

/***/ }),

/***/ "C:\\Users\\XiaoMi\\AppData\\Roaming\\npm\\node_modules\\es6-tween\\bundled\\Tween.min.js":
/*!***************************************************************************************!*\
  !*** C:/Users/XiaoMi/AppData/Roaming/npm/node_modules/es6-tween/bundled/Tween.min.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {!function(t,e){ true?e(exports):undefined}(this,function(t){\"use strict\";function s(t){var e=u.indexOf(t);-1<e&&u.splice(e,1),u.push(t),p=0,l&&!f&&(o=c(i),f=!0)}function e(t){for(var e=0;e<u.length;e++)if(t===u[e])return u[e];return null}function F(){return f}function x(){return d}var o,r=\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:\"undefined\"!=typeof global?global:this||(void 0!==t?t:{}),n=r.requestAnimationFrame||function(t){return r.setTimeout(t,50/3)},a=r.cancelAnimationFrame||function(t){return r.clearTimeout(t)},C=function(){if(\"undefined\"==typeof process||void 0===process.hrtime||process.versions&&void 0!==process.versions.electron){if(void 0!==r.performance&&void 0!==r.performance.now)return r.performance.now.bind(r.performance);var t=r.performance&&r.performance.timing&&r.performance.timing.navigationStart?r.performance.timing.navigationStart:Date.now();return function(){return Date.now()-t}}return function(){var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}}(),u=[],f=!1,l=!1,h=[],c=n,p=0,y=120,d=!0,N=function(t){var e=u.indexOf(t);-1!==e&&u.splice(e,1),0===u.length&&(a(o),f=!1)},i=function t(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:C(),r=1<arguments.length?arguments[1]:void 0;if(y<=p&&d)return f=!1,p=0,a(o),!1;l&&f?o=c(t):function(){for(var t=0;t<h.length;t++)h[t]()}(),u.length||p++;for(var n=0,i=u.length;n<i;)u[n++].update(e,r),i>u.length&&n--,i=u.length;return!0},q={},v={Linear:{None:function(t){return t}},Quadratic:{In:function(t){return Math.pow(t,2)},Out:function(t){return t*(2-t)},InOut:function(t){return(t*=2)<1?.5*Math.pow(t,2):-.5*(--t*(t-2)-1)}},Cubic:{In:function(t){return Math.pow(t,3)},Out:function(t){return--t*t*t+1},InOut:function(t){return(t*=2)<1?.5*Math.pow(t,3):.5*((t-=2)*t*t+2)}},Quartic:{In:function(t){return Math.pow(t,4)},Out:function(t){return 1- --t*t*t*t},InOut:function(t){return(t*=2)<1?.5*Math.pow(t,4):-.5*((t-=2)*t*t*t-2)}},Quintic:{In:function(t){return Math.pow(t,5)},Out:function(t){return--t*t*t*t*t+1},InOut:function(t){return(t*=2)<1?.5*Math.pow(t,5):.5*((t-=2)*t*t*t*t+2)}},Sinusoidal:{In:function(t){return 1-Math.cos(t*Math.PI/2)},Out:function(t){return Math.sin(t*Math.PI/2)},InOut:function(t){return.5*(1-Math.cos(Math.PI*t))}},Exponential:{In:function(t){return 0===t?0:Math.pow(1024,t-1)},Out:function(t){return 1===t?1:1-Math.pow(2,-10*t)},InOut:function(t){return 0===t?0:1===t?1:(t*=2)<1?.5*Math.pow(1024,t-1):.5*(2-Math.pow(2,-10*(t-1)))}},Circular:{In:function(t){return 1-Math.sqrt(1-t*t)},Out:function(t){return Math.sqrt(1- --t*t)},InOut:function(t){return(t*=2)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)}},Elastic:{In:function(t){return 0===t?0:1===t?1:-Math.pow(2,10*(t-1))*Math.sin(5*(t-1.1)*Math.PI)},Out:function(t){return 0===t?0:1===t?1:Math.pow(2,-10*t)*Math.sin(5*(t-.1)*Math.PI)+1},InOut:function(t){return 0===t?0:1===t?1:(t*=2)<1?-.5*Math.pow(2,10*(t-1))*Math.sin(5*(t-1.1)*Math.PI):.5*Math.pow(2,-10*(t-1))*Math.sin(5*(t-1.1)*Math.PI)+1}},Back:{In:function(t){return t*t*(2.70158*t-1.70158)},Out:function(t){return--t*t*(2.70158*t+1.70158)+1},InOut:function(t){var e=2.5949095;return(t*=2)<1?t*t*((1+e)*t-e)*.5:.5*((t-=2)*t*((1+e)*t+e)+2)}},Bounce:{In:function(t){return 1-v.Bounce.Out(1-t)},Out:function(t){var e=2.75,r=7.5625;return t<1/e?r*t*t:t<2/e?r*(t-=1.5/e)*t+.75:t<2.5/e?r*(t-=2.25/e)*t+.9375:r*(t-=2.625/e)*t+.984375},InOut:function(t){return t<.5?.5*v.Bounce.In(2*t):.5*v.Bounce.Out(2*t-1)+.5}},Stepped:{steps:function(e){return function(t){return(t*e|0)/e}}}};function m(t){return(m=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function _(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function g(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function b(t,e,r){return e&&g(t.prototype,e),r&&g(t,r),t}function T(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),r.push.apply(r,n)}return r}function O(i){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?T(Object(o),!0).forEach(function(t){var e,r,n;e=i,n=o[r=t],r in e?Object.defineProperty(e,r,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[r]=n}):Object.getOwnPropertyDescriptors?Object.defineProperties(i,Object.getOwnPropertyDescriptors(o)):T(Object(o)).forEach(function(t){Object.defineProperty(i,t,Object.getOwnPropertyDescriptor(o,t))})}return i}function w(t){return(w=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function k(t,e){return(k=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function j(t){if(void 0===t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return t}function A(t,e){return!e||\"object\"!=typeof e&&\"function\"!=typeof e?j(t):e}function S(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){if(!(Symbol.iterator in Object(t)||\"[object Arguments]\"===Object.prototype.toString.call(t)))return;var r=[],n=!0,i=!1,o=void 0;try{for(var s,a=t[Symbol.iterator]();!(n=(s=a.next()).done)&&(r.push(s.value),!e||r.length!==e);n=!0);}catch(t){i=!0,o=t}finally{try{n||null==a.return||a.return()}finally{if(i)throw o}}return r}(t,e)||function(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance\")}()}var D=50/3,U=\"_chainedTweens\",E=\"Callback\",V=\"update\",B=\"complete\",G=\"start\",z=\"repeat\",Q=\"reverse\",P=\"restart\",M=\"STRING_PROP\",R=/\\s+|([A-Za-z?().,{}:\"\"[\\]#%]+)|([-+]=+)?([-+]+)?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]=?\\d+)?/g;function I(t){if(t&&t.nodeType||void 0===t||\"object\"!==m(t))return t;if(Array.isArray(t))return[].concat(t);if(\"object\"!==m(t))return t;var e={};for(var r in t)e[r]=I(t[r]);return e}var L=function(t){return isNaN(+t)||(\"+\"===t[0]||\"-\"===t[0])&&\"=\"===t[1]||\"\"===t||\" \"===t},K=/^#([0-9a-f]{6}|[0-9a-f]{3})$/gi,W=function(t,e){var r,n,i;3===e.length&&(e=(r=e[0])+r+(n=e[1])+n+(i=e[2])+i);var o=parseInt(e,16);return\"rgb(\"+(r=o>>16&255)+\", \"+(n=o>>8&255)+\", \"+(i=255&o)+\")\"};function H(t){if(t&&t.splice&&t.isString)return t;if(\"string\"!=typeof t)return t;if(\"=\"===t.charAt(1))return t;var e=t.replace(K,W).match(R).map(function(t){return L(t)?t:+t});return e.isString=!0,e}function X(r,n,t,e){var i=t[r],o=e[r];if(i===o)return!0;if(Array.isArray(i)&&Array.isArray(o)&&i.length===o.length)for(var s=0,a=o.length;s<a;s++){var u=i[s],f=o[s];u===f||\"number\"==typeof u&&\"number\"==typeof f||X(s,n[r],i,o)}if(!(\"number\"==typeof i&&\"number\"==typeof o||i&&i.splice&&i.isString&&o&&o.splice&&o.isString)){if(\"string\"==typeof i&&Array.isArray(o)){var l=H(i),h=o.map(H);return t[r]=l,e[r]=h,!0}if(\"string\"==typeof i||\"string\"==typeof o){var c=Array.isArray(i)&&i[0]===M?i:H(i),p=Array.isArray(o)&&o[0]===M?o:H(o);if(void 0===c)return;for(var y=1;y<c.length;)c[y]===p[y]&&\"string\"==typeof c[y-1]?(c.splice(y-1,2,c[y-1]+c[y]),p.splice(y-1,2,p[y-1]+p[y])):y++;return c[y=0]===M&&c.shift(),p[0]===M&&p.shift(),t[r]=c,e[r]=p,!0}if(\"object\"===m(i)&&\"object\"===m(o)){if(Array.isArray(i)&&!i.isString)return i.map(function(t,e){return X(e,n[r],i,o)});for(var d in o)X(d,n[r],i,o);return!0}}return!1}var Y=\"rgba(\",Z=function(t,e,r){var n=2<arguments.length&&void 0!==r?r:\"rgb(\";return\"number\"==typeof t[e]&&(t[e-1]===n||t[e-3]===n||t[e-5]===n)};function $(t,e,r,n,i,o,s){var a=s?r:r[t],u=s?n:n[t];if(void 0===u)return a;if(void 0===a||\"string\"==typeof a||a===u)return u;if(\"object\"===m(a)&&\"object\"===m(u)){if(!a||!u)return e[t];if(\"object\"===m(a)&&a&&a.isString&&u&&u.splice&&u.isString){for(var f=\"\",l=0,h=a.length;l<h;l++)if(a[l]!==u[l]||\"number\"!=typeof a[l]||\"number\"==typeof u[l]){var c=\"number\"==typeof a[l]&&\"string\"==typeof u[l]&&\"=\"===u[l][1],p=\"number\"!=typeof a[l]?a[l]:c?a[l]+parseFloat(u[l][0]+u[l].substr(2))*i:a[l]+(u[l]-a[l])*i;(Z(a,l)||Z(a,l,Y))&&(p|=0),f+=p,c&&1===o&&(a[l]=a[l]+parseFloat(u[l][0]+u[l].substr(2)))}else f+=a[l];return s||(e[t]=f),f}if(Array.isArray(a)&&a[0]!==M)for(var y=0,d=a.length;y<d;y++)a[y]!==u[y]&&\"string\"!=typeof e[t]&&$(y,e[t],a,u,i,o);else if(\"object\"===m(a)&&a&&!a.isString)for(var v in a)a[v]!==u[v]&&$(v,e[t],a,u,i,o)}else if(\"number\"==typeof a){var _=\"string\"==typeof u;e[t]=_?a+parseFloat(u[0]+u.substr(2))*i:a+(u-a)*i,_&&1===o&&(r[t]=e[t])}else\"function\"==typeof u&&(e[t]=u(i));return e[t]}function J(t,e){var i=t[e],o=e.replace(nt,\"\").split(rt),s=o.length-1,a=Array.isArray(t),u=\"object\"===m(t)&&!a;return u?(t[e]=null,delete t[e]):a&&t.splice(e,1),o.reduce(function(t,e,r){a&&\".\"!==e&&\"[\"!==e&&(e*=1);var n=\"[\"===o[r+1];if(\".\"===e||\"[\"===e)return\".\"===e?a=!(u=!0):\"[\"===e&&(a=!(u=!1)),t;if(void 0===t[e]){if(a||u)return t[e]=r===s?i:a||n?[]:u?{}:null,u=a=!1,t[e]}else if(void 0!==t[e])return r===s&&(t[e]=i),t[e];return t},t)}function tt(t){if(\"object\"===m(t)&&t)for(var e in t)if(-1!==e.indexOf(\".\")||-1!==e.indexOf(\"[\"))J(t,e);else if(\"object\"===m(t[e])&&t[e]){var r=t[e];for(var n in r)if(-1!==n.indexOf(\".\")||-1!==n.indexOf(\"[\"))J(r,n);else if(\"object\"===m(r[n])&&r[n]){var i=r[n];for(var o in i)-1===o.indexOf(\".\")&&-1===o.indexOf(\"[\")||J(i,o)}}return t}var et,rt=/([.[])/g,nt=/\\]/g,it=Object.freeze({__proto__:null,FRAME_MS:D,TOO_LONG_FRAME_MS:250,CHAINED_TWEENS:U,EVENT_CALLBACK:E,EVENT_UPDATE:V,EVENT_COMPLETE:B,EVENT_START:G,EVENT_REPEAT:z,EVENT_REVERSE:Q,EVENT_PAUSE:\"pause\",EVENT_PLAY:\"play\",EVENT_RESTART:P,EVENT_STOP:\"stop\",EVENT_SEEK:\"seek\",STRING_PROP:M,NUM_REGEX:R,deepCopy:I,decomposeString:H,decompose:X,RGB:\"rgb(\",RGBA:Y,isRGBColor:Z,recompose:$,SET_NESTED:tt}),ot={Linear:function(t,e,r){var n=t.length-1,i=n*e,o=Math.floor(i),s=ot.Utils.Linear;return e<0?s(t[0],t[1],i,r):1<e?s(t[n],t[n-1],n-i,r):s(t[o],t[n<o+1?n:o+1],i-o,r)},Bezier:function(t,e,r){for(var n=ot.Utils.Reset(r),i=t.length-1,o=Math.pow,s=ot.Utils.Bernstein,a=Array.isArray(n),u=0;u<=i;u++)if(\"number\"==typeof n)n+=o(1-e,i-u)*o(e,u)*t[u]*s(i,u);else if(a)for(var f=0,l=n.length;f<l;f++)\"number\"==typeof n[f]?n[f]+=o(1-e,i-u)*o(e,u)*t[u][f]*s(i,u):n[f]=t[u][f];else if(\"object\"===m(n))for(var h in n)\"number\"==typeof n[h]?n[h]+=o(1-e,i-u)*o(e,u)*t[u][h]*s(i,u):n[h]=t[u][h];else if(\"string\"==typeof n){for(var c=\"\",p=t[Math.round(i*e)],y=1,d=p.length;y<d;y++)c+=p[y];return c}return n},CatmullRom:function(t,e,r){var n=t.length-1,i=n*e,o=Math.floor(i),s=ot.Utils.CatmullRom;return t[0]===t[n]?(e<0&&(o=Math.floor(i=n*(1+e))),s(t[(o-1+n)%n],t[o],t[(o+1)%n],t[(o+2)%n],i-o,r)):e<0?s(t[1],t[1],t[0],t[0],-e,r):1<e?s(t[n-1],t[n-1],t[n],t[n],(0|e)-e,r):s(t[o?o-1:0],t[o],t[n<o+1?n:o+1],t[n<o+2?n:o+2],i-o,r)},Utils:{Linear:function(t,e,r,n){if(t===e||\"string\"==typeof t){if(e.length&&e.splice&&e.isString){e=\"\";for(var i=0,o=t.length;i<o;i++)e+=t[i]}return e}if(\"number\"==typeof t)return\"function\"==typeof t?t(r):t+(e-t)*r;if(\"object\"===m(t)){if(void 0!==t.length){var s=\"string\"==typeof t[0]||t.isString;if(s||t[0]===M){for(var a=\"\",u=s?0:1,f=t.length;u<f;u++){var l=0===r?t[u]:1!==r&&\"number\"==typeof t[u]?t[u]+(e[u]-t[u])*r:e[u];(0<r&&r<1&&Z(t,u)||Z(t,u,Y))&&(l|=0),a+=l}return a}if(n&&n.length&&n.splice)for(var h=0,c=n.length;h<c;h++)n[h]=ot.Utils.Linear(t[h],e[h],r,n[h])}else for(var p in n)n[p]=ot.Utils.Linear(t[p],e[p],r,n[p]);return n}},Reset:function(t){if(Array.isArray(t)){for(var e=0,r=t.length;e<r;e++)t[e]=ot.Utils.Reset(t[e]);return t}if(\"object\"!==m(t))return\"number\"==typeof t?0:t;for(var n in t)t[n]=ot.Utils.Reset(t[n]);return t},Bernstein:function(t,e){var r=ot.Utils.Factorial;return r(t)/r(e)/r(t-e)},Factorial:(et=[1],function(t){var e=1;if(et[t])return et[t];for(var r=t;1<r;r--)e*=r;return et[t]=e}),CatmullRom:function(t,e,r,n,i,o){if(\"string\"==typeof t)return e;if(\"number\"==typeof t){var s=.5*(r-t),a=.5*(n-e),u=i*i;return(2*e-2*r+s+a)*(i*u)+(-3*e+3*r-2*s-a)*u+s*i+e}if(\"object\"===m(t)){if(void 0!==t.length){if(t[0]===M){for(var f=\"\",l=1,h=t.length;l<h;l++){var c=\"number\"==typeof t[l]?ot.Utils.CatmullRom(t[l],e[l],r[l],n[l],i):n[l];(Z(t,l)||Z(t,l,Y))&&(c|=0),f+=c}return f}for(var p=0,y=o.length;p<y;p++)o[p]=ot.Utils.CatmullRom(t[p],e[p],r[p],n[p],i,o[p])}else for(var d in o)o[d]=ot.Utils.CatmullRom(t[d],e[d],r[d],n[d],i,o[d]);return o}}}},st={};function at(t,e,r){if(!t||!t.nodeType)return e;var n=t.queueID||\"q_\"+Date.now();t.queueID||(t.queueID=n);var i=st[n];if(i){if(i.object===e&&t===i.tween.node&&r._startTime===i.tween._startTime)N(i.tween);else if(\"object\"===m(e)&&e&&i.object){for(var o in e)o in i.object&&(r._startTime===i.tween._startTime?delete i.object[o]:i.propNormaliseRequired=!0);Object.assign(i.object,e)}return i.object}return\"object\"===m(e)&&e?(st[n]={tween:r,object:e,propNormaliseRequired:!1},st[n].object):e}function ut(t,e,r){return e?t?\"undefined\"!=typeof window&&t===window||\"undefined\"!=typeof document&&t===document?[t]:\"string\"==typeof t?!!document.querySelectorAll&&document.querySelectorAll(t):Array.isArray(t)?t:t.nodeType?[t]:r?t:[]:null:t?\"undefined\"!=typeof window&&t===window||\"undefined\"!=typeof document&&t===document?t:\"string\"==typeof t?!!document.querySelector&&document.querySelector(t):Array.isArray(t)?t[0]:t.nodeType||r?t:null:null}var ft=0,lt=v.Linear.None,ht=function(){function L(t,e){return _(this,L),this.id=ft++,!t||\"object\"!==m(t)||e||t.nodeType?t&&(t.nodeType||t.length||\"string\"==typeof t)&&(t=this.node=ut(t),e=this.object=at(t,e,this)):(e=this.object=t,t=null),this._valuesEnd=null,this._valuesStart=Array.isArray(e)?[]:{},this._duration=1e3,this._easingFunction=lt,this._easingReverse=lt,this._interpolationFunction=ot.Linear,this._startTime=0,this._initTime=0,this._delayTime=0,this._repeat=0,this._r=0,this._isPlaying=!1,this._yoyo=!1,this._reversed=!1,this._onStartCallbackFired=!1,this._pausedTime=null,this._isFinite=!0,this._maxListener=15,this._chainedTweensCount=0,this._prevTime=null,this}return b(L,null,[{key:\"fromTo\",value:function(t,e,r,n){var i=3<arguments.length&&void 0!==n?n:{};i.quickRender=i.quickRender?i.quickRender:!r;var o=new L(t,e).to(r,i);return i.quickRender&&(o.render().update(o._startTime),o._rendered=!1,o._onStartCallbackFired=!1),o}},{key:\"to\",value:function(t,e,r){return L.fromTo(t,null,e,r)}},{key:\"from\",value:function(t,e,r){return L.fromTo(t,e,null,r)}}]),b(L,[{key:\"setMaxListener\",value:function(t){var e=0<arguments.length&&void 0!==t?t:15;return this._maxListener=e,this}},{key:\"on\",value:function(t,e){for(var r=this._maxListener,n=t+E,i=0;i<r;i++){var o=n+i;if(!this[o]){this[o]=e;break}}return this}},{key:\"once\",value:function(t,i){for(var o=this,e=this._maxListener,r=t+E,n=function(t){var n=r+t;if(!o[n])return o[n]=function(){for(var t=arguments.length,e=new Array(t),r=0;r<t;r++)e[r]=arguments[r];i.apply(o,e),o[n]=null},\"break\"},s=0;s<e;s++){if(\"break\"===n(s))break}return this}},{key:\"off\",value:function(t,e){for(var r=this._maxListener,n=t+E,i=0;i<r;i++){var o=n+i;this[o]===e&&(this[o]=null)}return this}},{key:\"emit\",value:function(t,e,r,n){var i=this._maxListener,o=t+E;if(!this[o+0])return this;for(var s=0;s<i;s++){var a=o+s;this[a]&&this[a](e,r,n)}return this}},{key:\"isPlaying\",value:function(){return this._isPlaying}},{key:\"isStarted\",value:function(){return this._onStartCallbackFired}},{key:\"reverse\",value:function(t){var e=this._reversed;return this._reversed=void 0!==t?t:!e,this}},{key:\"reversed\",value:function(){return this._reversed}},{key:\"pause\",value:function(){return this._isPlaying?(this._isPlaying=!1,N(this),this._pausedTime=C(),this.emit(\"pause\",this.object)):this}},{key:\"play\",value:function(){return this._isPlaying?this:(this._isPlaying=!0,this._startTime+=C()-this._pausedTime,this._initTime=this._startTime,s(this),this._pausedTime=C(),this.emit(\"play\",this.object))}},{key:\"restart\",value:function(){return this._repeat=this._r,this.reassignValues(),s(this),this.emit(P,this.object)}},{key:\"seek\",value:function(t,e){var r=this._duration,n=this._initTime,i=this._startTime,o=this._reversed,s=n+t;return this._isPlaying=!0,s<i&&n<=i&&(this._startTime-=r,this._reversed=!o),this.update(t,!1),this.emit(\"seek\",t,this.object),e?this:this.pause()}},{key:\"duration\",value:function(t){return this._duration=\"function\"==typeof t?t(this._duration):t,this}},{key:\"to\",value:function(t,e){var r=1<arguments.length&&void 0!==e?e:1e3;if(this._valuesEnd=t,\"number\"==typeof r||\"function\"==typeof r)this._duration=\"function\"==typeof r?r(this._duration):r;else if(\"object\"===m(r))for(var n in r)if(\"function\"==typeof this[n]){var i=S(Array.isArray(r[n])?r[n]:[r[n]],4),o=i[0],s=void 0===o?null:o,a=i[1],u=void 0===a?null:a,f=i[2],l=void 0===f?null:f,h=i[3],c=void 0===h?null:h;this[n](s,u,l,c)}return this}},{key:\"render\",value:function(){if(this._rendered)return this;var t=this._valuesStart,e=this._valuesEnd,r=this.object,n=this.node,i=this.InitialValues;if(tt(r),tt(e),n&&n.queueID&&st[n.queueID]){var o=st[n.queueID];if(o.propNormaliseRequired&&o.tween!==this){for(var s in e)o.tween._valuesEnd[s];o.normalisedProp=!0,o.propNormaliseRequired=!1}}if(n&&i&&(r&&0!==Object.keys(r).length?e&&0!==Object.keys(e).length||(e=this._valuesEnd=i(n,r)):r=this.object=at(n,i(n,e),this)),!t.processed){for(var a in e){var u=r&&r[a]&&I(r[a]),f=e[a];if(!(q[a]&&q[a].init&&(q[a].init.call(this,u,f,a,r),void 0===u&&t[a]&&(u=t[a]),q[a].skipProcess))&&!(\"number\"==typeof u&&isNaN(u)||null===u||null===f||!1===u||!1===f||void 0===u||void 0===f||u===f)){if(t[a]=u,Array.isArray(f))if(Array.isArray(u))f.isString&&r[a].isString&&!u.isString?u.isString=!0:X(a,r,t,e);else{f.unshift(u);for(var l=0,h=f.length;l<h;l++)\"string\"==typeof f[l]&&(f[l]=H(f[l]))}else X(a,r,t,e);\"number\"!=typeof u||\"string\"!=typeof f||f[1]}}t.processed=!0}return L.Renderer&&this.node&&L.Renderer.init&&(L.Renderer.init.call(this,r,t,e),this.__render=!0),this._rendered=!0,this}},{key:\"start\",value:function(t){return this._startTime=void 0!==t?\"string\"==typeof t?C()+parseFloat(t):t:C(),this._startTime+=this._delayTime,this._initTime=this._prevTime=this._startTime,this._onStartCallbackFired=!1,this._rendered=!1,this._isPlaying=!0,s(this),this}},{key:\"stop\",value:function(){var t=this._isPlaying,e=this._isFinite,r=this.object,n=this._startTime,i=this._duration,o=this._r,s=this._yoyo,a=this._reversed;if(!t)return this;var u=e?(o+1)%2==1:!a;return this._reversed=!1,s&&u?this.update(n):this.update(n+i),N(this),this.emit(\"stop\",r)}},{key:\"delay\",value:function(t){return this._delayTime=\"function\"==typeof t?t(this._delayTime):t,this}},{key:\"chainedTweens\",value:function(){if(this._chainedTweensCount=arguments.length,!this._chainedTweensCount)return this;for(var t=0,e=this._chainedTweensCount;t<e;t++)this[U+t]=arguments[t];return this}},{key:\"repeat\",value:function(t){return this._repeat=this._duration?\"function\"==typeof t?t(this._repeat):t:0,this._r=this._repeat,this._isFinite=isFinite(t),this}},{key:\"reverseDelay\",value:function(t){return this._reverseDelayTime=\"function\"==typeof t?t(this._reverseDelayTime):t,this}},{key:\"yoyo\",value:function(t,e){return this._yoyo=\"function\"==typeof t?t(this._yoyo):null===t?this._yoyo:t,t||(this._reversed=!1),this._easingReverse=e||null,this}},{key:\"easing\",value:function(t){return this._easingFunction=t,this}},{key:\"interpolation\",value:function(t){return\"function\"==typeof t&&(this._interpolationFunction=t),this}},{key:\"reassignValues\",value:function(t){var e=this._valuesStart,r=this.object,n=this._delayTime;for(var i in this._isPlaying=!0,this._startTime=void 0!==t?t:C(),this._startTime+=n,this._reversed=!1,s(this),e){var o=e[i];r[i]=o}return this}},{key:\"update\",value:function(t,e,r){var n,i,o,s=this._onStartCallbackFired,a=this._easingFunction,u=this._interpolationFunction,f=this._easingReverse,l=this._repeat,h=this._delayTime,c=this._reverseDelayTime,p=this._yoyo,y=this._reversed,d=this._startTime,v=this._prevTime,_=this._duration,m=this._valuesStart,g=this._valuesEnd,b=this.object,T=this._isFinite,O=this._isPlaying,w=this.__render,k=this._chainedTweensCount,j=0;if(_){var A=(t=void 0!==t?t:C())-v;if(this._prevTime=t,250<A&&F()&&x()&&(t-=A-D),!O||t<d&&!r)return!0;n=1<(n=(t-d)/_)?1:n,n=y?1-n:n}else n=1,l=0;if(s||(this._rendered||(this.render(),this._rendered=!0),this.emit(G,b),this._onStartCallbackFired=!0),i=y&&f||a,!b)return!0;for(o in g){var S=m[o];if(null!=S||q[o]&&q[o].update){var E=g[o],P=i[o]?i[o](n):(\"function\"==typeof i?i:lt)(n),M=u[o]?u[o]:\"function\"==typeof u?u:ot.Linear;\"number\"==typeof E?b[o]=S+(E-S)*P:!Array.isArray(E)||E.isString||Array.isArray(S)?E&&E.update?E.update(P):\"function\"==typeof E?b[o]=E(P):\"string\"==typeof E&&\"number\"==typeof S?b[o]=S+parseFloat(E[0]+E.substr(2))*P:$(o,b,m,g,P,n):b[o]=M(E,P,b[o]),q[o]&&q[o].update&&q[o].update.call(this,b[o],S,E,P,n,o),j++}}if(!j)return N(this),!1;if(w&&L.Renderer&&L.Renderer.update&&L.Renderer.update.call(this,b,n),this.emit(V,b,n,t),1===n||y&&0===n){if(0<l&&0<_){if(T&&this._repeat--,p)this._reversed=!y;else for(o in g){var R=g[o];\"string\"==typeof R&&\"number\"==typeof m[o]&&(m[o]+=parseFloat(R[0]+R.substr(2)))}return this.emit(p&&!y?Q:z,b),this._startTime=y&&c?t-c:t+h,!0}if(e||(this._isPlaying=!1,N(this),ft--),this.emit(B,b),this._repeat=this._r,k)for(var I=0;I<k;I++)this[U+I].start(t+_);return!1}return!0}}]),L}(),ct=function(){function t(){_(this,t),this.totalTime=0,this.labels=[],this.offsets=[]}return b(t,[{key:\"parseLabel\",value:function(t,e){var r=this.offsets,n=this.labels,i=n.indexOf(t);if(\"string\"==typeof t&&-1!==t.indexOf(\"=\")&&!e&&-1===i){var o=t.substr(t.indexOf(\"=\")-1,2),s=t.split(o);e=2===s.length?o+s[1]:null,t=s[0],i=n.indexOf(t)}if(-1!==i&&t){var a=r[i]||0;if(\"number\"==typeof e)a=e;else if(\"string\"==typeof e&&-1!==e.indexOf(\"=\")){var u=e.charAt(0);e=Number(e.substr(2)),\"+\"===u||\"-\"===u?a+=parseFloat(u+e):\"*\"===u?a*=e:\"/\"===u?a/=e:\"%\"===u&&(a*=e/100)}return a}return\"number\"==typeof e?e:0}},{key:\"addLabel\",value:function(t,e){return this.labels.push(t),this.offsets.push(this.parseLabel(t,e)),this}},{key:\"setLabel\",value:function(t,e){var r=this.labels.indexOf(t);return-1!==r&&this.offsets.splice(r,1,this.parseLabel(t,e)),this}},{key:\"eraseLabel\",value:function(t){var e=this.labels.indexOf(t);return-1!==e&&(this.labels.splice(e,1),this.offsets.splice(e,1)),this}}]),t}(),pt=0,yt=function(){function r(t){var e;return _(this,r),(e=A(this,w(r).call(this)))._duration=0,e._startTime=t&&void 0!==t.startTime?t.startTime:C(),e._tweens=[],e.elapsed=0,e._id=pt++,e._defaultParams=t,e.position=new ct,e.position.addLabel(\"afterLast\",e._duration),e.position.addLabel(\"afterInit\",e._startTime),e._onStartCallbackFired=!1,A(e,j(e))}return function(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&k(t,e)}(r,ht),b(r,[{key:\"mapTotal\",value:function(t){return t.call(this,this._tweens),this}},{key:\"timingOrder\",value:function(t){var r=t(this._tweens.map(function(t){return t._startTime}));return this._tweens.map(function(t,e){t._startTime=r[e]}),this}},{key:\"getTiming\",value:function(t,e,r,n){var i=3<arguments.length&&void 0!==n?n:0;if(\"reverse\"===t){var o=r.stagger,s=(o||0)*(e.length-1);return e.map(function(t,e){return s-(o||0)*e+i})}if(\"async\"===t)return e.map(function(t){return i});if(\"sequence\"===t||\"delayed\"===t){var a=r.stagger;return a=a||(r.duration||1e3)/(e.length-1),e.map(function(t,e){return a*e+i})}if(\"oneByOne\"===t)return e.map(function(t){return r.duration});if(\"shuffle\"===t){var u=r.stagger;return function(t){var e,r,n;for(n=t.length;n;--n)e=Math.floor(Math.random()*n),r=t[n-1],t[n-1]=t[e],t[e]=r;return t}(e.map(function(t,e){return(u||0)*e+i}))}var f=r.stagger;return e.map(function(t,e){return(f||0)*e+i})}},{key:\"fromTo\",value:function(t,e,r,n){if((t=ut(t,!0,!0))&&t.length){this._defaultParams&&(n=n?O({},this._defaultParams,{},n):this._defaultParams);for(var i,o=n.label,s=\"number\"==typeof o?o:this.position.parseLabel(void 0!==o?o:\"afterLast\",null),a=this.getTiming(n.mode,t,n,s),u=0,f=t.length;u<f;u++)i=t[u],this.add(ht.fromTo(i,\"function\"==typeof e?e(u,t.length):\"object\"===m(e)&&e?O({},e):null,\"function\"==typeof r?r(u,t.length):r,\"function\"==typeof n?n(u,t.length):n),a[u])}return this.start()}},{key:\"from\",value:function(t,e,r){return this.fromTo(t,e,null,r)}},{key:\"to\",value:function(t,e,r){return this.fromTo(t,null,e,r)}},{key:\"addLabel\",value:function(t,e){return this.position.addLabel(t,e),this}},{key:\"map\",value:function(t){for(var e=0,r=this._tweens.length;e<r;e++){var n=this._tweens[e];t(n,e),this._duration=Math.max(this._duration,n._duration+n._startTime)}return this}},{key:\"add\",value:function(t,e){var r=this;if(Array.isArray(t))return t.map(function(t){r.add(t,e)}),this;\"object\"!==m(t)||t instanceof ht||(t=new ht(t.from).to(t.to,t));var n=this._defaultParams,i=this._duration;if(n)for(var o in n)\"function\"==typeof t[o]&&t[o](n[o]);var s=\"number\"==typeof e?e:this.position.parseLabel(void 0!==e?e:\"afterLast\",null);return t._startTime=Math.max(this._startTime,t._delayTime,s),t._delayTime=s,t._isPlaying=!0,this._duration=Math.max(i,Math.max(t._startTime+t._delayTime,t._duration)),this._tweens.push(t),this.position.setLabel(\"afterLast\",this._duration),this}},{key:\"restart\",value:function(){return this._startTime+=C(),s(this),this.emit(P)}},{key:\"easing\",value:function(e){return this.map(function(t){return t.easing(e)})}},{key:\"interpolation\",value:function(e){return this.map(function(t){return t.interpolation(e)})}},{key:\"update\",value:function(t){var e,r=this._tweens,n=this._duration,i=this._reverseDelayTime,o=this._startTime,s=this._reversed,a=this._yoyo,u=this._repeat,f=this._isFinite,l=this._isPlaying,h=this._prevTime,c=this._onStartCallbackFired,p=(t=void 0!==t?t:C())-h;if(this._prevTime=t,250<p&&F()&&x()&&(t-=p-D),!l||t<o)return!0;e=1<(e=(t-o)/n)?1:e,e=s?1-e:e,this.elapsed=e,c||(this.emit(G),this._onStartCallbackFired=!0);for(var y=t-o,d=s?n-y:y,v=0;v<r.length;)r[v].update(d),v++;if(this.emit(V,e,y),1===e||s&&0===e){if(u){for(f&&this._repeat--,this.emit(s?Q:z),a&&(this._reversed=!s,this.timingOrder(function(t){return t.reverse()})),this._startTime=s&&i?t+i:t,v=0;v<r.length;)r[v].reassignValues(t),v++;return!0}return this.emit(B),this._repeat=this._r,N(this),this._isPlaying=!1}return!0}},{key:\"progress\",value:function(t){return void 0!==t?this.update(t*this._duration):this.elapsed}}]),r}();t.Easing=v,t.FrameThrottle=function(t){y=1.05*(0<arguments.length&&void 0!==t?t:120)},t.Interpolation=ot,t.Interpolator=function(i,o){var s=Array.isArray(i)&&!i.isString,a=\"string\"==typeof i?i:s?i.slice():O({},i);if(s)for(var t=0,e=i.length;t<e;t++)i[t]===o[t]&&\"number\"==typeof i[t]&&\"number\"!=typeof o[t]||X(t,a,i,o);else if(\"object\"===m(i))for(var r in i)i[r]===o[r]&&\"number\"==typeof i[r]&&\"number\"!=typeof o[r]||X(r,a,i,o);else if(\"string\"==typeof i){i=H(i),o=H(o);for(var n=1;n<i.length;)i[n]===o[n]&&\"string\"==typeof i[n-1]?(i.splice(n-1,2,i[n-1]+i[n]),o.splice(n-1,2,o[n-1]+o[n])):n++}return function(t){if(s)for(var e=0,r=i.length;e<r;e++)$(e,a,i,o,t);else if(\"object\"===m(a))for(var n in i)$(n,a,i,o,t);else\"string\"==typeof a&&(a=$(0,0,i,o,t,t,!0));return a}},t.Plugins=q,t.Selector=ut,t.Timeline=yt,t.ToggleLagSmoothing=function(t){d=!(0<arguments.length&&void 0!==t)||t},t.Tween=ht,t.add=s,t.autoPlay=function(t){l=t},t.get=e,t.getAll=function(){return u},t.has=function(t){return null!==e(t)},t.isRunning=F,t.now=C,t.onRequestTick=function(t){h.push(t)},t.onTick=function(t){return u.push({update:t})},t.remove=N,t.removeAll=function(){u.length=0,a(o),f=!1},t.update=i,t.utils=it,Object.defineProperty(t,\"__esModule\",{value:!0})});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! (webpack)/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./node_modules/process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://threeD/C:/Users/XiaoMi/AppData/Roaming/npm/node_modules/es6-tween/bundled/Tween.min.js?");

/***/ }),

/***/ "C:\\Users\\XiaoMi\\AppData\\Roaming\\npm\\node_modules\\hammerjs\\hammer.js":
/*!***************************************************************************!*\
  !*** C:/Users/XiaoMi/AppData/Roaming/npm/node_modules/hammerjs/hammer.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function(window, document, exportName, undefined) {\n  'use strict';\n\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = document.createElement('div');\n\nvar TYPE_FUNCTION = 'function';\n\nvar round = Math.round;\nvar abs = Math.abs;\nvar now = Date.now;\n\n/**\n * set a timeout with a given scope\n * @param {Function} fn\n * @param {Number} timeout\n * @param {Object} context\n * @returns {number}\n */\nfunction setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n}\n\n/**\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\nfunction invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n        each(arg, context[fn], context);\n        return true;\n    }\n    return false;\n}\n\n/**\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n        return;\n    }\n\n    if (obj.forEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n        i = 0;\n        while (i < obj.length) {\n            iterator.call(context, obj[i], i, obj);\n            i++;\n        }\n    } else {\n        for (i in obj) {\n            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n        }\n    }\n}\n\n/**\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n    return function() {\n        var e = new Error('get-stack-trace');\n        var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '')\n            .replace(/^\\s+at\\s+/gm, '')\n            .replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\n        var log = window.console && (window.console.warn || window.console.log);\n        if (log) {\n            log.call(window.console, deprecationMessage, stack);\n        }\n        return method.apply(this, arguments);\n    };\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nvar assign;\nif (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n        if (target === undefined || target === null) {\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        var output = Object(target);\n        for (var index = 1; index < arguments.length; index++) {\n            var source = arguments[index];\n            if (source !== undefined && source !== null) {\n                for (var nextKey in source) {\n                    if (source.hasOwnProperty(nextKey)) {\n                        output[nextKey] = source[nextKey];\n                    }\n                }\n            }\n        }\n        return output;\n    };\n} else {\n    assign = Object.assign;\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\nvar extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n    while (i < keys.length) {\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\n            dest[keys[i]] = src[keys[i]];\n        }\n        i++;\n    }\n    return dest;\n}, 'extend', 'Use `assign`.');\n\n/**\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\nvar merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\n/**\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\nfunction inherit(child, base, properties) {\n    var baseP = base.prototype,\n        childP;\n\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n        assign(childP, properties);\n    }\n}\n\n/**\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n    return function boundFn() {\n        return fn.apply(context, arguments);\n    };\n}\n\n/**\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\nfunction boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n        return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n}\n\n/**\n * use the val2 when val1 is undefined\n * @param {*} val1\n * @param {*} val2\n * @returns {*}\n */\nfunction ifUndefined(val1, val2) {\n    return (val1 === undefined) ? val2 : val1;\n}\n\n/**\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction addEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.addEventListener(type, handler, false);\n    });\n}\n\n/**\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction removeEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.removeEventListener(type, handler, false);\n    });\n}\n\n/**\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n    while (node) {\n        if (node == parent) {\n            return true;\n        }\n        node = node.parentNode;\n    }\n    return false;\n}\n\n/**\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n    return str.indexOf(find) > -1;\n}\n\n/**\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n    return str.trim().split(/\\s+/g);\n}\n\n/**\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n        return src.indexOf(find);\n    } else {\n        var i = 0;\n        while (i < src.length) {\n            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\n                return i;\n            }\n            i++;\n        }\n        return -1;\n    }\n}\n\n/**\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\nfunction uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n        var val = key ? src[i][key] : src[i];\n        if (inArray(values, val) < 0) {\n            results.push(src[i]);\n        }\n        values[i] = val;\n        i++;\n    }\n\n    if (sort) {\n        if (!key) {\n            results = results.sort();\n        } else {\n            results = results.sort(function sortUniqueArray(a, b) {\n                return a[key] > b[key];\n            });\n        }\n    }\n\n    return results;\n}\n\n/**\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\nfunction prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n\n    var i = 0;\n    while (i < VENDOR_PREFIXES.length) {\n        prefix = VENDOR_PREFIXES[i];\n        prop = (prefix) ? prefix + camelProp : property;\n\n        if (prop in obj) {\n            return prop;\n        }\n        i++;\n    }\n    return undefined;\n}\n\n/**\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n    return _uniqueId++;\n}\n\n/**\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return (doc.defaultView || doc.parentWindow || window);\n}\n\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\n\nvar COMPUTE_INTERVAL = 25;\n\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\n\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\n\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\nfunction Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function(ev) {\n        if (boolOrFn(manager.options.enable, [manager])) {\n            self.handler(ev);\n        }\n    };\n\n    this.init();\n\n}\n\nInput.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function() { },\n\n    /**\n     * bind the events\n     */\n    init: function() {\n        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function() {\n        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n};\n\n/**\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nfunction createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n        Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n        Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n        Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n        Type = MouseInput;\n    } else {\n        Type = TouchMouseInput;\n    }\n    return new (Type)(manager, inputHandler);\n}\n\n/**\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nfunction inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n        manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit('hammer.input', input);\n\n    manager.recognize(input);\n    manager.session.prevInput = input;\n}\n\n/**\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nfunction computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n        session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n        session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n        session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\n\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\n        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\n\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n        target = input.srcEvent.target;\n    }\n    input.target = target;\n}\n\nfunction computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n        prevDelta = session.prevDelta = {\n            x: prevInput.deltaX || 0,\n            y: prevInput.deltaY || 0\n        };\n\n        offset = session.offsetDelta = {\n            x: center.x,\n            y: center.y\n        };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nfunction computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n        deltaTime = input.timeStamp - last.timeStamp,\n        velocity, velocityX, velocityY, direction;\n\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n        var deltaX = input.deltaX - last.deltaX;\n        var deltaY = input.deltaY - last.deltaY;\n\n        var v = getVelocity(deltaTime, deltaX, deltaY);\n        velocityX = v.x;\n        velocityY = v.y;\n        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n        direction = getDirection(deltaX, deltaY);\n\n        session.lastInterval = input;\n    } else {\n        // use latest velocity info if it doesn't overtake a minimum period\n        velocity = last.velocity;\n        velocityX = last.velocityX;\n        velocityY = last.velocityY;\n        direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n}\n\n/**\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nfunction simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n        pointers[i] = {\n            clientX: round(input.pointers[i].clientX),\n            clientY: round(input.pointers[i].clientY)\n        };\n        i++;\n    }\n\n    return {\n        timeStamp: now(),\n        pointers: pointers,\n        center: getCenter(pointers),\n        deltaX: input.deltaX,\n        deltaY: input.deltaY\n    };\n}\n\n/**\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nfunction getCenter(pointers) {\n    var pointersLength = pointers.length;\n\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n        return {\n            x: round(pointers[0].clientX),\n            y: round(pointers[0].clientY)\n        };\n    }\n\n    var x = 0, y = 0, i = 0;\n    while (i < pointersLength) {\n        x += pointers[i].clientX;\n        y += pointers[i].clientY;\n        i++;\n    }\n\n    return {\n        x: round(x / pointersLength),\n        y: round(y / pointersLength)\n    };\n}\n\n/**\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n    return {\n        x: x / deltaTime || 0,\n        y: y / deltaTime || 0\n    };\n}\n\n/**\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nfunction getDirection(x, y) {\n    if (x === y) {\n        return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\n/**\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nfunction getDistance(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n\n    return Math.sqrt((x * x) + (y * y));\n}\n\n/**\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nfunction getAngle(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nfunction getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nfunction getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\nvar MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n};\n\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n/**\n * Mouse events input\n * @constructor\n * @extends Input\n */\nfunction MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n}\n\ninherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n        var eventType = MOUSE_INPUT_MAP[ev.type];\n\n        // on start we want to have the left mouse button down\n        if (eventType & INPUT_START && ev.button === 0) {\n            this.pressed = true;\n        }\n\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\n            eventType = INPUT_END;\n        }\n\n        // mouse must be down\n        if (!this.pressed) {\n            return;\n        }\n\n        if (eventType & INPUT_END) {\n            this.pressed = false;\n        }\n\n        this.callback(this.manager, eventType, {\n            pointers: [ev],\n            changedPointers: [ev],\n            pointerType: INPUT_TYPE_MOUSE,\n            srcEvent: ev\n        });\n    }\n});\n\nvar POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n};\n\n// in IE10 the pointer types is defined as an enum\nvar IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n// IE10 has prefixed support, and case-sensitive\nif (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n\n/**\n * Pointer events input\n * @constructor\n * @extends Input\n */\nfunction PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n\n    Input.apply(this, arguments);\n\n    this.store = (this.manager.session.pointerEvents = []);\n}\n\ninherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n        var store = this.store;\n        var removePointer = false;\n\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n        var isTouch = (pointerType == INPUT_TYPE_TOUCH);\n\n        // get index of the event in the store\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n        // start and mouse must be down\n        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n            if (storeIndex < 0) {\n                store.push(ev);\n                storeIndex = store.length - 1;\n            }\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n            removePointer = true;\n        }\n\n        // it not found, so the pointer hasn't been down (so it's probably a hover)\n        if (storeIndex < 0) {\n            return;\n        }\n\n        // update the event in the store\n        store[storeIndex] = ev;\n\n        this.callback(this.manager, eventType, {\n            pointers: store,\n            changedPointers: [ev],\n            pointerType: pointerType,\n            srcEvent: ev\n        });\n\n        if (removePointer) {\n            // remove from the store\n            store.splice(storeIndex, 1);\n        }\n    }\n});\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Touch events input\n * @constructor\n * @extends Input\n */\nfunction SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n\n    Input.apply(this, arguments);\n}\n\ninherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n        // should we handle the touch events?\n        if (type === INPUT_START) {\n            this.started = true;\n        }\n\n        if (!this.started) {\n            return;\n        }\n\n        var touches = normalizeSingleTouches.call(this, ev, type);\n\n        // when done, reset the started state\n        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n            this.started = false;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n        all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n\n    return [all, changed];\n}\n\nvar TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\nfunction TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n\n    Input.apply(this, arguments);\n}\n\ninherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n        var type = TOUCH_INPUT_MAP[ev.type];\n        var touches = getTouches.call(this, ev, type);\n        if (!touches) {\n            return;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds;\n\n    // when there is only one touch, the process can be simplified\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n        targetIds[allTouches[0].identifier] = true;\n        return [allTouches, allTouches];\n    }\n\n    var i,\n        targetTouches,\n        changedTouches = toArray(ev.changedTouches),\n        changedTargetTouches = [],\n        target = this.target;\n\n    // get target touches from touches\n    targetTouches = allTouches.filter(function(touch) {\n        return hasParent(touch.target, target);\n    });\n\n    // collect touches\n    if (type === INPUT_START) {\n        i = 0;\n        while (i < targetTouches.length) {\n            targetIds[targetTouches[i].identifier] = true;\n            i++;\n        }\n    }\n\n    // filter changed touches to only contain touches that exist in the collected target ids\n    i = 0;\n    while (i < changedTouches.length) {\n        if (targetIds[changedTouches[i].identifier]) {\n            changedTargetTouches.push(changedTouches[i]);\n        }\n\n        // cleanup removed touches\n        if (type & (INPUT_END | INPUT_CANCEL)) {\n            delete targetIds[changedTouches[i].identifier];\n        }\n        i++;\n    }\n\n    if (!changedTargetTouches.length) {\n        return;\n    }\n\n    return [\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n        changedTargetTouches\n    ];\n}\n\n/**\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nfunction TouchMouseInput() {\n    Input.apply(this, arguments);\n\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n\n    this.primaryTouch = null;\n    this.lastTouches = [];\n}\n\ninherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\n            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n            return;\n        }\n\n        // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n        if (isTouch) {\n            recordTouches.call(this, inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n            return;\n        }\n\n        this.callback(manager, inputEvent, inputData);\n    },\n\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n        this.touch.destroy();\n        this.mouse.destroy();\n    }\n});\n\nfunction recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n        this.primaryTouch = eventData.changedPointers[0].identifier;\n        setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        setLastTouch.call(this, eventData);\n    }\n}\n\nfunction setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n\n    if (touch.identifier === this.primaryTouch) {\n        var lastTouch = {x: touch.clientX, y: touch.clientY};\n        this.lastTouches.push(lastTouch);\n        var lts = this.lastTouches;\n        var removeLastTouch = function() {\n            var i = lts.indexOf(lastTouch);\n            if (i > -1) {\n                lts.splice(i, 1);\n            }\n        };\n        setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n}\n\nfunction isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;\n    for (var i = 0; i < this.lastTouches.length; i++) {\n        var t = this.lastTouches[i];\n        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);\n        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n// magical touchAction value\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\n\n/**\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\nfunction TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n}\n\nTouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function(value) {\n        // find out the touch-action by the event handlers\n        if (value == TOUCH_ACTION_COMPUTE) {\n            value = this.compute();\n        }\n\n        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n        }\n        this.actions = value.toLowerCase().trim();\n    },\n\n    /**\n     * just re-set the touchAction value\n     */\n    update: function() {\n        this.set(this.manager.options.touchAction);\n    },\n\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function() {\n        var actions = [];\n        each(this.manager.recognizers, function(recognizer) {\n            if (boolOrFn(recognizer.options.enable, [recognizer])) {\n                actions = actions.concat(recognizer.getTouchAction());\n            }\n        });\n        return cleanTouchActions(actions.join(' '));\n    },\n\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function(input) {\n        var srcEvent = input.srcEvent;\n        var direction = input.offsetDirection;\n\n        // if the touch action did prevented once this session\n        if (this.manager.session.prevented) {\n            srcEvent.preventDefault();\n            return;\n        }\n\n        var actions = this.actions;\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n        if (hasNone) {\n            //do not prevent defaults if this is a tap gesture\n\n            var isTapPointer = input.pointers.length === 1;\n            var isTapMovement = input.distance < 2;\n            var isTapTouchTime = input.deltaTime < 250;\n\n            if (isTapPointer && isTapMovement && isTapTouchTime) {\n                return;\n            }\n        }\n\n        if (hasPanX && hasPanY) {\n            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n            return;\n        }\n\n        if (hasNone ||\n            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n            (hasPanX && direction & DIRECTION_VERTICAL)) {\n            return this.preventSrc(srcEvent);\n        }\n    },\n\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function(srcEvent) {\n        this.manager.session.prevented = true;\n        srcEvent.preventDefault();\n    }\n};\n\n/**\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\nfunction cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n    // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n    if (hasPanX && hasPanY) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    // pan-x OR pan-y\n    if (hasPanX || hasPanY) {\n        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    }\n\n    // manipulation\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n        return TOUCH_ACTION_MANIPULATION;\n    }\n\n    return TOUCH_ACTION_AUTO;\n}\n\nfunction getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n        return false;\n    }\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {\n\n        // If css.supports is not supported but there is native touch-action assume it supports\n        // all values. This is the case for IE 10 and 11.\n        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n}\n\n/**\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\nfunction Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n\n    this.state = STATE_POSSIBLE;\n\n    this.simultaneous = {};\n    this.requireFail = [];\n}\n\nRecognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // also update the touchAction, in case something changed about the directions/enabled state\n        this.manager && this.manager.touchAction.update();\n        return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n            return this;\n        }\n\n        var simultaneous = this.simultaneous;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (!simultaneous[otherRecognizer.id]) {\n            simultaneous[otherRecognizer.id] = otherRecognizer;\n            otherRecognizer.recognizeWith(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        delete this.simultaneous[otherRecognizer.id];\n        return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n            return this;\n        }\n\n        var requireFail = this.requireFail;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (inArray(requireFail, otherRecognizer) === -1) {\n            requireFail.push(otherRecognizer);\n            otherRecognizer.requireFailure(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        var index = inArray(this.requireFail, otherRecognizer);\n        if (index > -1) {\n            this.requireFail.splice(index, 1);\n        }\n        return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function() {\n        return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function(otherRecognizer) {\n        return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function(input) {\n        var self = this;\n        var state = this.state;\n\n        function emit(event) {\n            self.manager.emit(event, input);\n        }\n\n        // 'panstart' and 'panmove'\n        if (state < STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n\n        emit(self.options.event); // simple 'eventName' events\n\n        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\n            emit(input.additionalEvent);\n        }\n\n        // panend and pancancel\n        if (state >= STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function(input) {\n        if (this.canEmit()) {\n            return this.emit(input);\n        }\n        // it's failing anyway\n        this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function() {\n        var i = 0;\n        while (i < this.requireFail.length) {\n            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        // make a new copy of the inputData\n        // so we can change the inputData without messing up the other recognizers\n        var inputDataClone = assign({}, inputData);\n\n        // is is enabled and allow recognizing?\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n            this.reset();\n            this.state = STATE_FAILED;\n            return;\n        }\n\n        // reset when we've reached the end\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n            this.state = STATE_POSSIBLE;\n        }\n\n        this.state = this.process(inputDataClone);\n\n        // the recognizer has recognized a gesture\n        // so trigger an event\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n            this.tryEmit(inputDataClone);\n        }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function(inputData) { }, // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function() { },\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function() { }\n};\n\n/**\n * get a usable string, used as event postfix\n * @param {Const} state\n * @returns {String} state\n */\nfunction stateStr(state) {\n    if (state & STATE_CANCELLED) {\n        return 'cancel';\n    } else if (state & STATE_ENDED) {\n        return 'end';\n    } else if (state & STATE_CHANGED) {\n        return 'move';\n    } else if (state & STATE_BEGAN) {\n        return 'start';\n    }\n    return '';\n}\n\n/**\n * direction cons to string\n * @param {Const} direction\n * @returns {String}\n */\nfunction directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n        return 'down';\n    } else if (direction == DIRECTION_UP) {\n        return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n        return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n        return 'right';\n    }\n    return '';\n}\n\n/**\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n        return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n}\n\n/**\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\nfunction AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n}\n\ninherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n        /**\n         * @type {Number}\n         * @default 1\n         */\n        pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function(input) {\n        var optionPointers = this.options.pointers;\n        return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function(input) {\n        var state = this.state;\n        var eventType = input.eventType;\n\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n        var isValid = this.attrTest(input);\n\n        // on cancel input and we've recognized before, return STATE_CANCELLED\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n            return state | STATE_CANCELLED;\n        } else if (isRecognized || isValid) {\n            if (eventType & INPUT_END) {\n                return state | STATE_ENDED;\n            } else if (!(state & STATE_BEGAN)) {\n                return STATE_BEGAN;\n            }\n            return state | STATE_CHANGED;\n        }\n        return STATE_FAILED;\n    }\n});\n\n/**\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n\n    this.pX = null;\n    this.pY = null;\n}\n\ninherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n        event: 'pan',\n        threshold: 10,\n        pointers: 1,\n        direction: DIRECTION_ALL\n    },\n\n    getTouchAction: function() {\n        var direction = this.options.direction;\n        var actions = [];\n        if (direction & DIRECTION_HORIZONTAL) {\n            actions.push(TOUCH_ACTION_PAN_Y);\n        }\n        if (direction & DIRECTION_VERTICAL) {\n            actions.push(TOUCH_ACTION_PAN_X);\n        }\n        return actions;\n    },\n\n    directionTest: function(input) {\n        var options = this.options;\n        var hasMoved = true;\n        var distance = input.distance;\n        var direction = input.direction;\n        var x = input.deltaX;\n        var y = input.deltaY;\n\n        // lock to axis?\n        if (!(direction & options.direction)) {\n            if (options.direction & DIRECTION_HORIZONTAL) {\n                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n                hasMoved = x != this.pX;\n                distance = Math.abs(input.deltaX);\n            } else {\n                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n                hasMoved = y != this.pY;\n                distance = Math.abs(input.deltaY);\n            }\n        }\n        input.direction = direction;\n        return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n\n    attrTest: function(input) {\n        return AttrRecognizer.prototype.attrTest.call(this, input) &&\n            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n    },\n\n    emit: function(input) {\n\n        this.pX = input.deltaX;\n        this.pY = input.deltaY;\n\n        var direction = directionStr(input.direction);\n\n        if (direction) {\n            input.additionalEvent = this.options.event + direction;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'pinch',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n\n    emit: function(input) {\n        if (input.scale !== 1) {\n            var inOut = input.scale < 1 ? 'in' : 'out';\n            input.additionalEvent = this.options.event + inOut;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\nfunction PressRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    this._timer = null;\n    this._input = null;\n}\n\ninherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n        event: 'press',\n        pointers: 1,\n        time: 251, // minimal time of the pointer to be pressed\n        threshold: 9 // a minimal movement is ok, but keep it low\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_AUTO];\n    },\n\n    process: function(input) {\n        var options = this.options;\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTime = input.deltaTime > options.time;\n\n        this._input = input;\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n            this.reset();\n        } else if (input.eventType & INPUT_START) {\n            this.reset();\n            this._timer = setTimeoutContext(function() {\n                this.state = STATE_RECOGNIZED;\n                this.tryEmit();\n            }, options.time, this);\n        } else if (input.eventType & INPUT_END) {\n            return STATE_RECOGNIZED;\n        }\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function(input) {\n        if (this.state !== STATE_RECOGNIZED) {\n            return;\n        }\n\n        if (input && (input.eventType & INPUT_END)) {\n            this.manager.emit(this.options.event + 'up', input);\n        } else {\n            this._input.timeStamp = now();\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n        event: 'rotate',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n});\n\n/**\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n        event: 'swipe',\n        threshold: 10,\n        velocity: 0.3,\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n        pointers: 1\n    },\n\n    getTouchAction: function() {\n        return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n\n    attrTest: function(input) {\n        var direction = this.options.direction;\n        var velocity;\n\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n            velocity = input.overallVelocity;\n        } else if (direction & DIRECTION_HORIZONTAL) {\n            velocity = input.overallVelocityX;\n        } else if (direction & DIRECTION_VERTICAL) {\n            velocity = input.overallVelocityY;\n        }\n\n        return this._super.attrTest.call(this, input) &&\n            direction & input.offsetDirection &&\n            input.distance > this.options.threshold &&\n            input.maxPointers == this.options.pointers &&\n            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n\n    emit: function(input) {\n        var direction = directionStr(input.offsetDirection);\n        if (direction) {\n            this.manager.emit(this.options.event + direction, input);\n        }\n\n        this.manager.emit(this.options.event, input);\n    }\n});\n\n/**\n * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\nfunction TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n}\n\ninherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'tap',\n        pointers: 1,\n        taps: 1,\n        interval: 300, // max time between the multi-tap taps\n        time: 250, // max time of the pointer to be down (like finger on the screen)\n        threshold: 9, // a minimal movement is ok, but keep it low\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_MANIPULATION];\n    },\n\n    process: function(input) {\n        var options = this.options;\n\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTouchTime = input.deltaTime < options.time;\n\n        this.reset();\n\n        if ((input.eventType & INPUT_START) && (this.count === 0)) {\n            return this.failTimeout();\n        }\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (validMovement && validTouchTime && validPointers) {\n            if (input.eventType != INPUT_END) {\n                return this.failTimeout();\n            }\n\n            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n            this.pTime = input.timeStamp;\n            this.pCenter = input.center;\n\n            if (!validMultiTap || !validInterval) {\n                this.count = 1;\n            } else {\n                this.count += 1;\n            }\n\n            this._input = input;\n\n            // if tap count matches we have recognized it,\n            // else it has began recognizing...\n            var tapCount = this.count % options.taps;\n            if (tapCount === 0) {\n                // no failing requirements, immediately trigger the tap event\n                // or wait as long as the multitap interval to trigger\n                if (!this.hasRequireFailures()) {\n                    return STATE_RECOGNIZED;\n                } else {\n                    this._timer = setTimeoutContext(function() {\n                        this.state = STATE_RECOGNIZED;\n                        this.tryEmit();\n                    }, options.interval, this);\n                    return STATE_BEGAN;\n                }\n            }\n        }\n        return STATE_FAILED;\n    },\n\n    failTimeout: function() {\n        this._timer = setTimeoutContext(function() {\n            this.state = STATE_FAILED;\n        }, this.options.interval, this);\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function() {\n        if (this.state == STATE_RECOGNIZED) {\n            this._input.tapCount = this.count;\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n}\n\n/**\n * @const {string}\n */\nHammer.VERSION = '2.0.7';\n\n/**\n * default settings\n * @namespace\n */\nHammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n        [RotateRecognizer, {enable: false}],\n        [PinchRecognizer, {enable: false}, ['rotate']],\n        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],\n        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],\n        [TapRecognizer],\n        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],\n        [PressRecognizer]\n    ],\n\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n        /**\n         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userSelect: 'none',\n\n        /**\n         * Disable the Windows Phone grippers when pressing an element.\n         * @type {String}\n         * @default 'none'\n         */\n        touchSelect: 'none',\n\n        /**\n         * Disables the default callout shown when you touch and hold a touch target.\n         * On iOS, when you touch and hold a touch target such as a link, Safari displays\n         * a callout containing information about the link. This property allows you to disable that callout.\n         * @type {String}\n         * @default 'none'\n         */\n        touchCallout: 'none',\n\n        /**\n         * Specifies whether zooming is enabled. Used by IE10>\n         * @type {String}\n         * @default 'none'\n         */\n        contentZooming: 'none',\n\n        /**\n         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userDrag: 'none',\n\n        /**\n         * Overrides the highlight color shown when the user taps a link or a JavaScript\n         * clickable element in iOS. This property obeys the alpha value, if specified.\n         * @type {String}\n         * @default 'rgba(0,0,0,0)'\n         */\n        tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n};\n\nvar STOP = 1;\nvar FORCED_STOP = 2;\n\n/**\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n\n    this.options.inputTarget = this.options.inputTarget || element;\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    toggleCssProps(this, true);\n\n    each(this.options.recognizers, function(item) {\n        var recognizer = this.add(new (item[0])(item[1]));\n        item[2] && recognizer.recognizeWith(item[2]);\n        item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n}\n\nManager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // Options that need a little more setup\n        if (options.touchAction) {\n            this.touchAction.update();\n        }\n        if (options.inputTarget) {\n            // Clean up existing event listeners and reinitialize\n            this.input.destroy();\n            this.input.target = options.inputTarget;\n            this.input.init();\n        }\n        return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function(force) {\n        this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        var session = this.session;\n        if (session.stopped) {\n            return;\n        }\n\n        // run the touch-action polyfill\n        this.touchAction.preventDefaults(inputData);\n\n        var recognizer;\n        var recognizers = this.recognizers;\n\n        // this holds the recognizer that is being recognized.\n        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n        // if no recognizer is detecting a thing, it is set to `null`\n        var curRecognizer = session.curRecognizer;\n\n        // reset when the last recognizer is recognized\n        // or when we're in a new session\n        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n            curRecognizer = session.curRecognizer = null;\n        }\n\n        var i = 0;\n        while (i < recognizers.length) {\n            recognizer = recognizers[i];\n\n            // find out if we are allowed try to recognize the input for this one.\n            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n            //      that is being recognized.\n            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n            //      this can be setup with the `recognizeWith()` method on the recognizer.\n            if (session.stopped !== FORCED_STOP && ( // 1\n                    !curRecognizer || recognizer == curRecognizer || // 2\n                    recognizer.canRecognizeWith(curRecognizer))) { // 3\n                recognizer.recognize(inputData);\n            } else {\n                recognizer.reset();\n            }\n\n            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n            // current active recognizer. but only if we don't already have an active recognizer\n            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n                curRecognizer = session.curRecognizer = recognizer;\n            }\n            i++;\n        }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function(recognizer) {\n        if (recognizer instanceof Recognizer) {\n            return recognizer;\n        }\n\n        var recognizers = this.recognizers;\n        for (var i = 0; i < recognizers.length; i++) {\n            if (recognizers[i].options.event == recognizer) {\n                return recognizers[i];\n            }\n        }\n        return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'add', this)) {\n            return this;\n        }\n\n        // remove existing\n        var existing = this.get(recognizer.options.event);\n        if (existing) {\n            this.remove(existing);\n        }\n\n        this.recognizers.push(recognizer);\n        recognizer.manager = this;\n\n        this.touchAction.update();\n        return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'remove', this)) {\n            return this;\n        }\n\n        recognizer = this.get(recognizer);\n\n        // let's make sure this recognizer exists\n        if (recognizer) {\n            var recognizers = this.recognizers;\n            var index = inArray(recognizers, recognizer);\n\n            if (index !== -1) {\n                recognizers.splice(index, 1);\n                this.touchAction.update();\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n        if (handler === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            handlers[event] = handlers[event] || [];\n            handlers[event].push(handler);\n        });\n        return this;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            if (!handler) {\n                delete handlers[event];\n            } else {\n                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n            }\n        });\n        return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function(event, data) {\n        // we also want to trigger dom events\n        if (this.options.domEvents) {\n            triggerDomEvent(event, data);\n        }\n\n        // no handlers, so skip it all\n        var handlers = this.handlers[event] && this.handlers[event].slice();\n        if (!handlers || !handlers.length) {\n            return;\n        }\n\n        data.type = event;\n        data.preventDefault = function() {\n            data.srcEvent.preventDefault();\n        };\n\n        var i = 0;\n        while (i < handlers.length) {\n            handlers[i](data);\n            i++;\n        }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function() {\n        this.element && toggleCssProps(this, false);\n\n        this.handlers = {};\n        this.session = {};\n        this.input.destroy();\n        this.element = null;\n    }\n};\n\n/**\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\nfunction toggleCssProps(manager, add) {\n    var element = manager.element;\n    if (!element.style) {\n        return;\n    }\n    var prop;\n    each(manager.options.cssProps, function(value, name) {\n        prop = prefixed(element.style, name);\n        if (add) {\n            manager.oldCssProps[prop] = element.style[prop];\n            element.style[prop] = value;\n        } else {\n            element.style[prop] = manager.oldCssProps[prop] || '';\n        }\n    });\n    if (!add) {\n        manager.oldCssProps = {};\n    }\n}\n\n/**\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\nfunction triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n}\n\nassign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n});\n\n// this prevents errors when Hammer is loaded in the presence of an AMD\n//  style loader but by script tag, not by the loader.\nvar freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line\nfreeGlobal.Hammer = Hammer;\n\nif (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n        return Hammer;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {}\n\n})(window, document, 'Hammer');\n\n\n//# sourceURL=webpack://threeD/C:/Users/XiaoMi/AppData/Roaming/npm/node_modules/hammerjs/hammer.js?");

/***/ }),

/***/ "C:\\Users\\XiaoMi\\AppData\\Roaming\\npm\\node_modules\\three\\examples\\jsm\\libs\\stats.module.js":
/*!************************************************************************************************!*\
  !*** C:/Users/XiaoMi/AppData/Roaming/npm/node_modules/three/examples/jsm/libs/stats.module.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nvar Stats = function () {\n\n\tvar mode = 0;\n\n\tvar container = document.createElement( 'div' );\n\tcontainer.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000';\n\tcontainer.addEventListener( 'click', function ( event ) {\n\n\t\tevent.preventDefault();\n\t\tshowPanel( ++ mode % container.children.length );\n\n\t}, false );\n\n\t//\n\n\tfunction addPanel( panel ) {\n\n\t\tcontainer.appendChild( panel.dom );\n\t\treturn panel;\n\n\t}\n\n\tfunction showPanel( id ) {\n\n\t\tfor ( var i = 0; i < container.children.length; i ++ ) {\n\n\t\t\tcontainer.children[ i ].style.display = i === id ? 'block' : 'none';\n\n\t\t}\n\n\t\tmode = id;\n\n\t}\n\n\t//\n\n\tvar beginTime = ( performance || Date ).now(), prevTime = beginTime, frames = 0;\n\n\tvar fpsPanel = addPanel( new Stats.Panel( 'FPS', '#0ff', '#002' ) );\n\tvar msPanel = addPanel( new Stats.Panel( 'MS', '#0f0', '#020' ) );\n\n\tif ( self.performance && self.performance.memory ) {\n\n\t\tvar memPanel = addPanel( new Stats.Panel( 'MB', '#f08', '#201' ) );\n\n\t}\n\n\tshowPanel( 0 );\n\n\treturn {\n\n\t\tREVISION: 16,\n\n\t\tdom: container,\n\n\t\taddPanel: addPanel,\n\t\tshowPanel: showPanel,\n\n\t\tbegin: function () {\n\n\t\t\tbeginTime = ( performance || Date ).now();\n\n\t\t},\n\n\t\tend: function () {\n\n\t\t\tframes ++;\n\n\t\t\tvar time = ( performance || Date ).now();\n\n\t\t\tmsPanel.update( time - beginTime, 200 );\n\n\t\t\tif ( time >= prevTime + 1000 ) {\n\n\t\t\t\tfpsPanel.update( ( frames * 1000 ) / ( time - prevTime ), 100 );\n\n\t\t\t\tprevTime = time;\n\t\t\t\tframes = 0;\n\n\t\t\t\tif ( memPanel ) {\n\n\t\t\t\t\tvar memory = performance.memory;\n\t\t\t\t\tmemPanel.update( memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn time;\n\n\t\t},\n\n\t\tupdate: function () {\n\n\t\t\tbeginTime = this.end();\n\n\t\t},\n\n\t\t// Backwards Compatibility\n\n\t\tdomElement: container,\n\t\tsetMode: showPanel\n\n\t};\n\n};\n\nStats.Panel = function ( name, fg, bg ) {\n\n\tvar min = Infinity, max = 0, round = Math.round;\n\tvar PR = round( window.devicePixelRatio || 1 );\n\n\tvar WIDTH = 80 * PR, HEIGHT = 48 * PR,\n\t\tTEXT_X = 3 * PR, TEXT_Y = 2 * PR,\n\t\tGRAPH_X = 3 * PR, GRAPH_Y = 15 * PR,\n\t\tGRAPH_WIDTH = 74 * PR, GRAPH_HEIGHT = 30 * PR;\n\n\tvar canvas = document.createElement( 'canvas' );\n\tcanvas.width = WIDTH;\n\tcanvas.height = HEIGHT;\n\tcanvas.style.cssText = 'width:80px;height:48px';\n\n\tvar context = canvas.getContext( '2d' );\n\tcontext.font = 'bold ' + ( 9 * PR ) + 'px Helvetica,Arial,sans-serif';\n\tcontext.textBaseline = 'top';\n\n\tcontext.fillStyle = bg;\n\tcontext.fillRect( 0, 0, WIDTH, HEIGHT );\n\n\tcontext.fillStyle = fg;\n\tcontext.fillText( name, TEXT_X, TEXT_Y );\n\tcontext.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT );\n\n\tcontext.fillStyle = bg;\n\tcontext.globalAlpha = 0.9;\n\tcontext.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT );\n\n\treturn {\n\n\t\tdom: canvas,\n\n\t\tupdate: function ( value, maxValue ) {\n\n\t\t\tmin = Math.min( min, value );\n\t\t\tmax = Math.max( max, value );\n\n\t\t\tcontext.fillStyle = bg;\n\t\t\tcontext.globalAlpha = 1;\n\t\t\tcontext.fillRect( 0, 0, WIDTH, GRAPH_Y );\n\t\t\tcontext.fillStyle = fg;\n\t\t\tcontext.fillText( round( value ) + ' ' + name + ' (' + round( min ) + '-' + round( max ) + ')', TEXT_X, TEXT_Y );\n\n\t\t\tcontext.drawImage( canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT );\n\n\t\t\tcontext.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT );\n\n\t\t\tcontext.fillStyle = bg;\n\t\t\tcontext.globalAlpha = 0.9;\n\t\t\tcontext.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round( ( 1 - ( value / maxValue ) ) * GRAPH_HEIGHT ) );\n\n\t\t}\n\n\t};\n\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Stats);\n\n\n//# sourceURL=webpack://threeD/C:/Users/XiaoMi/AppData/Roaming/npm/node_modules/three/examples/jsm/libs/stats.module.js?");

/***/ }),

/***/ "C:\\Users\\XiaoMi\\AppData\\Roaming\\npm\\node_modules\\webfontloader\\webfontloader.js":
/*!***************************************************************************************!*\
  !*** C:/Users/XiaoMi/AppData/Roaming/npm/node_modules/webfontloader/webfontloader.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* Web Font Loader v1.6.28 - (c) Adobe Systems, Google. License: Apache 2.0 */(function(){function aa(a,b,c){return a.call.apply(a.bind,arguments)}function ba(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function p(a,b,c){p=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf(\"native code\")?aa:ba;return p.apply(null,arguments)}var q=Date.now||function(){return+new Date};function ca(a,b){this.a=a;this.o=b||a;this.c=this.o.document}var da=!!window.FontFace;function t(a,b,c,d){b=a.c.createElement(b);if(c)for(var e in c)c.hasOwnProperty(e)&&(\"style\"==e?b.style.cssText=c[e]:b.setAttribute(e,c[e]));d&&b.appendChild(a.c.createTextNode(d));return b}function u(a,b,c){a=a.c.getElementsByTagName(b)[0];a||(a=document.documentElement);a.insertBefore(c,a.lastChild)}function v(a){a.parentNode&&a.parentNode.removeChild(a)}\nfunction w(a,b,c){b=b||[];c=c||[];for(var d=a.className.split(/\\s+/),e=0;e<b.length;e+=1){for(var f=!1,g=0;g<d.length;g+=1)if(b[e]===d[g]){f=!0;break}f||d.push(b[e])}b=[];for(e=0;e<d.length;e+=1){f=!1;for(g=0;g<c.length;g+=1)if(d[e]===c[g]){f=!0;break}f||b.push(d[e])}a.className=b.join(\" \").replace(/\\s+/g,\" \").replace(/^\\s+|\\s+$/,\"\")}function y(a,b){for(var c=a.className.split(/\\s+/),d=0,e=c.length;d<e;d++)if(c[d]==b)return!0;return!1}\nfunction ea(a){return a.o.location.hostname||a.a.location.hostname}function z(a,b,c){function d(){m&&e&&f&&(m(g),m=null)}b=t(a,\"link\",{rel:\"stylesheet\",href:b,media:\"all\"});var e=!1,f=!0,g=null,m=c||null;da?(b.onload=function(){e=!0;d()},b.onerror=function(){e=!0;g=Error(\"Stylesheet failed to load\");d()}):setTimeout(function(){e=!0;d()},0);u(a,\"head\",b)}\nfunction A(a,b,c,d){var e=a.c.getElementsByTagName(\"head\")[0];if(e){var f=t(a,\"script\",{src:b}),g=!1;f.onload=f.onreadystatechange=function(){g||this.readyState&&\"loaded\"!=this.readyState&&\"complete\"!=this.readyState||(g=!0,c&&c(null),f.onload=f.onreadystatechange=null,\"HEAD\"==f.parentNode.tagName&&e.removeChild(f))};e.appendChild(f);setTimeout(function(){g||(g=!0,c&&c(Error(\"Script load timeout\")))},d||5E3);return f}return null};function B(){this.a=0;this.c=null}function C(a){a.a++;return function(){a.a--;D(a)}}function E(a,b){a.c=b;D(a)}function D(a){0==a.a&&a.c&&(a.c(),a.c=null)};function F(a){this.a=a||\"-\"}F.prototype.c=function(a){for(var b=[],c=0;c<arguments.length;c++)b.push(arguments[c].replace(/[\\W_]+/g,\"\").toLowerCase());return b.join(this.a)};function G(a,b){this.c=a;this.f=4;this.a=\"n\";var c=(b||\"n4\").match(/^([nio])([1-9])$/i);c&&(this.a=c[1],this.f=parseInt(c[2],10))}function fa(a){return H(a)+\" \"+(a.f+\"00\")+\" 300px \"+I(a.c)}function I(a){var b=[];a=a.split(/,\\s*/);for(var c=0;c<a.length;c++){var d=a[c].replace(/['\"]/g,\"\");-1!=d.indexOf(\" \")||/^\\d/.test(d)?b.push(\"'\"+d+\"'\"):b.push(d)}return b.join(\",\")}function J(a){return a.a+a.f}function H(a){var b=\"normal\";\"o\"===a.a?b=\"oblique\":\"i\"===a.a&&(b=\"italic\");return b}\nfunction ga(a){var b=4,c=\"n\",d=null;a&&((d=a.match(/(normal|oblique|italic)/i))&&d[1]&&(c=d[1].substr(0,1).toLowerCase()),(d=a.match(/([1-9]00|normal|bold)/i))&&d[1]&&(/bold/i.test(d[1])?b=7:/[1-9]00/.test(d[1])&&(b=parseInt(d[1].substr(0,1),10))));return c+b};function ha(a,b){this.c=a;this.f=a.o.document.documentElement;this.h=b;this.a=new F(\"-\");this.j=!1!==b.events;this.g=!1!==b.classes}function ia(a){a.g&&w(a.f,[a.a.c(\"wf\",\"loading\")]);K(a,\"loading\")}function L(a){if(a.g){var b=y(a.f,a.a.c(\"wf\",\"active\")),c=[],d=[a.a.c(\"wf\",\"loading\")];b||c.push(a.a.c(\"wf\",\"inactive\"));w(a.f,c,d)}K(a,\"inactive\")}function K(a,b,c){if(a.j&&a.h[b])if(c)a.h[b](c.c,J(c));else a.h[b]()};function ja(){this.c={}}function ka(a,b,c){var d=[],e;for(e in b)if(b.hasOwnProperty(e)){var f=a.c[e];f&&d.push(f(b[e],c))}return d};function M(a,b){this.c=a;this.f=b;this.a=t(this.c,\"span\",{\"aria-hidden\":\"true\"},this.f)}function N(a){u(a.c,\"body\",a.a)}function O(a){return\"display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:\"+I(a.c)+\";\"+(\"font-style:\"+H(a)+\";font-weight:\"+(a.f+\"00\")+\";\")};function P(a,b,c,d,e,f){this.g=a;this.j=b;this.a=d;this.c=c;this.f=e||3E3;this.h=f||void 0}P.prototype.start=function(){var a=this.c.o.document,b=this,c=q(),d=new Promise(function(d,e){function f(){q()-c>=b.f?e():a.fonts.load(fa(b.a),b.h).then(function(a){1<=a.length?d():setTimeout(f,25)},function(){e()})}f()}),e=null,f=new Promise(function(a,d){e=setTimeout(d,b.f)});Promise.race([f,d]).then(function(){e&&(clearTimeout(e),e=null);b.g(b.a)},function(){b.j(b.a)})};function Q(a,b,c,d,e,f,g){this.v=a;this.B=b;this.c=c;this.a=d;this.s=g||\"BESbswy\";this.f={};this.w=e||3E3;this.u=f||null;this.m=this.j=this.h=this.g=null;this.g=new M(this.c,this.s);this.h=new M(this.c,this.s);this.j=new M(this.c,this.s);this.m=new M(this.c,this.s);a=new G(this.a.c+\",serif\",J(this.a));a=O(a);this.g.a.style.cssText=a;a=new G(this.a.c+\",sans-serif\",J(this.a));a=O(a);this.h.a.style.cssText=a;a=new G(\"serif\",J(this.a));a=O(a);this.j.a.style.cssText=a;a=new G(\"sans-serif\",J(this.a));a=\nO(a);this.m.a.style.cssText=a;N(this.g);N(this.h);N(this.j);N(this.m)}var R={D:\"serif\",C:\"sans-serif\"},S=null;function T(){if(null===S){var a=/AppleWebKit\\/([0-9]+)(?:\\.([0-9]+))/.exec(window.navigator.userAgent);S=!!a&&(536>parseInt(a[1],10)||536===parseInt(a[1],10)&&11>=parseInt(a[2],10))}return S}Q.prototype.start=function(){this.f.serif=this.j.a.offsetWidth;this.f[\"sans-serif\"]=this.m.a.offsetWidth;this.A=q();U(this)};\nfunction la(a,b,c){for(var d in R)if(R.hasOwnProperty(d)&&b===a.f[R[d]]&&c===a.f[R[d]])return!0;return!1}function U(a){var b=a.g.a.offsetWidth,c=a.h.a.offsetWidth,d;(d=b===a.f.serif&&c===a.f[\"sans-serif\"])||(d=T()&&la(a,b,c));d?q()-a.A>=a.w?T()&&la(a,b,c)&&(null===a.u||a.u.hasOwnProperty(a.a.c))?V(a,a.v):V(a,a.B):ma(a):V(a,a.v)}function ma(a){setTimeout(p(function(){U(this)},a),50)}function V(a,b){setTimeout(p(function(){v(this.g.a);v(this.h.a);v(this.j.a);v(this.m.a);b(this.a)},a),0)};function W(a,b,c){this.c=a;this.a=b;this.f=0;this.m=this.j=!1;this.s=c}var X=null;W.prototype.g=function(a){var b=this.a;b.g&&w(b.f,[b.a.c(\"wf\",a.c,J(a).toString(),\"active\")],[b.a.c(\"wf\",a.c,J(a).toString(),\"loading\"),b.a.c(\"wf\",a.c,J(a).toString(),\"inactive\")]);K(b,\"fontactive\",a);this.m=!0;na(this)};\nW.prototype.h=function(a){var b=this.a;if(b.g){var c=y(b.f,b.a.c(\"wf\",a.c,J(a).toString(),\"active\")),d=[],e=[b.a.c(\"wf\",a.c,J(a).toString(),\"loading\")];c||d.push(b.a.c(\"wf\",a.c,J(a).toString(),\"inactive\"));w(b.f,d,e)}K(b,\"fontinactive\",a);na(this)};function na(a){0==--a.f&&a.j&&(a.m?(a=a.a,a.g&&w(a.f,[a.a.c(\"wf\",\"active\")],[a.a.c(\"wf\",\"loading\"),a.a.c(\"wf\",\"inactive\")]),K(a,\"active\")):L(a.a))};function oa(a){this.j=a;this.a=new ja;this.h=0;this.f=this.g=!0}oa.prototype.load=function(a){this.c=new ca(this.j,a.context||this.j);this.g=!1!==a.events;this.f=!1!==a.classes;pa(this,new ha(this.c,a),a)};\nfunction qa(a,b,c,d,e){var f=0==--a.h;(a.f||a.g)&&setTimeout(function(){var a=e||null,m=d||null||{};if(0===c.length&&f)L(b.a);else{b.f+=c.length;f&&(b.j=f);var h,l=[];for(h=0;h<c.length;h++){var k=c[h],n=m[k.c],r=b.a,x=k;r.g&&w(r.f,[r.a.c(\"wf\",x.c,J(x).toString(),\"loading\")]);K(r,\"fontloading\",x);r=null;if(null===X)if(window.FontFace){var x=/Gecko.*Firefox\\/(\\d+)/.exec(window.navigator.userAgent),xa=/OS X.*Version\\/10\\..*Safari/.exec(window.navigator.userAgent)&&/Apple/.exec(window.navigator.vendor);\nX=x?42<parseInt(x[1],10):xa?!1:!0}else X=!1;X?r=new P(p(b.g,b),p(b.h,b),b.c,k,b.s,n):r=new Q(p(b.g,b),p(b.h,b),b.c,k,b.s,a,n);l.push(r)}for(h=0;h<l.length;h++)l[h].start()}},0)}function pa(a,b,c){var d=[],e=c.timeout;ia(b);var d=ka(a.a,c,a.c),f=new W(a.c,b,e);a.h=d.length;b=0;for(c=d.length;b<c;b++)d[b].load(function(b,d,c){qa(a,f,b,d,c)})};function ra(a,b){this.c=a;this.a=b}\nra.prototype.load=function(a){function b(){if(f[\"__mti_fntLst\"+d]){var c=f[\"__mti_fntLst\"+d](),e=[],h;if(c)for(var l=0;l<c.length;l++){var k=c[l].fontfamily;void 0!=c[l].fontStyle&&void 0!=c[l].fontWeight?(h=c[l].fontStyle+c[l].fontWeight,e.push(new G(k,h))):e.push(new G(k))}a(e)}else setTimeout(function(){b()},50)}var c=this,d=c.a.projectId,e=c.a.version;if(d){var f=c.c.o;A(this.c,(c.a.api||\"https://fast.fonts.net/jsapi\")+\"/\"+d+\".js\"+(e?\"?v=\"+e:\"\"),function(e){e?a([]):(f[\"__MonotypeConfiguration__\"+\nd]=function(){return c.a},b())}).id=\"__MonotypeAPIScript__\"+d}else a([])};function sa(a,b){this.c=a;this.a=b}sa.prototype.load=function(a){var b,c,d=this.a.urls||[],e=this.a.families||[],f=this.a.testStrings||{},g=new B;b=0;for(c=d.length;b<c;b++)z(this.c,d[b],C(g));var m=[];b=0;for(c=e.length;b<c;b++)if(d=e[b].split(\":\"),d[1])for(var h=d[1].split(\",\"),l=0;l<h.length;l+=1)m.push(new G(d[0],h[l]));else m.push(new G(d[0]));E(g,function(){a(m,f)})};function ta(a,b){a?this.c=a:this.c=ua;this.a=[];this.f=[];this.g=b||\"\"}var ua=\"https://fonts.googleapis.com/css\";function va(a,b){for(var c=b.length,d=0;d<c;d++){var e=b[d].split(\":\");3==e.length&&a.f.push(e.pop());var f=\"\";2==e.length&&\"\"!=e[1]&&(f=\":\");a.a.push(e.join(f))}}\nfunction wa(a){if(0==a.a.length)throw Error(\"No fonts to load!\");if(-1!=a.c.indexOf(\"kit=\"))return a.c;for(var b=a.a.length,c=[],d=0;d<b;d++)c.push(a.a[d].replace(/ /g,\"+\"));b=a.c+\"?family=\"+c.join(\"%7C\");0<a.f.length&&(b+=\"&subset=\"+a.f.join(\",\"));0<a.g.length&&(b+=\"&text=\"+encodeURIComponent(a.g));return b};function ya(a){this.f=a;this.a=[];this.c={}}\nvar za={latin:\"BESbswy\",\"latin-ext\":\"\\u00e7\\u00f6\\u00fc\\u011f\\u015f\",cyrillic:\"\\u0439\\u044f\\u0416\",greek:\"\\u03b1\\u03b2\\u03a3\",khmer:\"\\u1780\\u1781\\u1782\",Hanuman:\"\\u1780\\u1781\\u1782\"},Aa={thin:\"1\",extralight:\"2\",\"extra-light\":\"2\",ultralight:\"2\",\"ultra-light\":\"2\",light:\"3\",regular:\"4\",book:\"4\",medium:\"5\",\"semi-bold\":\"6\",semibold:\"6\",\"demi-bold\":\"6\",demibold:\"6\",bold:\"7\",\"extra-bold\":\"8\",extrabold:\"8\",\"ultra-bold\":\"8\",ultrabold:\"8\",black:\"9\",heavy:\"9\",l:\"3\",r:\"4\",b:\"7\"},Ba={i:\"i\",italic:\"i\",n:\"n\",normal:\"n\"},\nCa=/^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/;\nfunction Da(a){for(var b=a.f.length,c=0;c<b;c++){var d=a.f[c].split(\":\"),e=d[0].replace(/\\+/g,\" \"),f=[\"n4\"];if(2<=d.length){var g;var m=d[1];g=[];if(m)for(var m=m.split(\",\"),h=m.length,l=0;l<h;l++){var k;k=m[l];if(k.match(/^[\\w-]+$/)){var n=Ca.exec(k.toLowerCase());if(null==n)k=\"\";else{k=n[2];k=null==k||\"\"==k?\"n\":Ba[k];n=n[1];if(null==n||\"\"==n)n=\"4\";else var r=Aa[n],n=r?r:isNaN(n)?\"4\":n.substr(0,1);k=[k,n].join(\"\")}}else k=\"\";k&&g.push(k)}0<g.length&&(f=g);3==d.length&&(d=d[2],g=[],d=d?d.split(\",\"):\ng,0<d.length&&(d=za[d[0]])&&(a.c[e]=d))}a.c[e]||(d=za[e])&&(a.c[e]=d);for(d=0;d<f.length;d+=1)a.a.push(new G(e,f[d]))}};function Ea(a,b){this.c=a;this.a=b}var Fa={Arimo:!0,Cousine:!0,Tinos:!0};Ea.prototype.load=function(a){var b=new B,c=this.c,d=new ta(this.a.api,this.a.text),e=this.a.families;va(d,e);var f=new ya(e);Da(f);z(c,wa(d),C(b));E(b,function(){a(f.a,f.c,Fa)})};function Ga(a,b){this.c=a;this.a=b}Ga.prototype.load=function(a){var b=this.a.id,c=this.c.o;b?A(this.c,(this.a.api||\"https://use.typekit.net\")+\"/\"+b+\".js\",function(b){if(b)a([]);else if(c.Typekit&&c.Typekit.config&&c.Typekit.config.fn){b=c.Typekit.config.fn;for(var e=[],f=0;f<b.length;f+=2)for(var g=b[f],m=b[f+1],h=0;h<m.length;h++)e.push(new G(g,m[h]));try{c.Typekit.load({events:!1,classes:!1,async:!0})}catch(l){}a(e)}},2E3):a([])};function Ha(a,b){this.c=a;this.f=b;this.a=[]}Ha.prototype.load=function(a){var b=this.f.id,c=this.c.o,d=this;b?(c.__webfontfontdeckmodule__||(c.__webfontfontdeckmodule__={}),c.__webfontfontdeckmodule__[b]=function(b,c){for(var g=0,m=c.fonts.length;g<m;++g){var h=c.fonts[g];d.a.push(new G(h.name,ga(\"font-weight:\"+h.weight+\";font-style:\"+h.style)))}a(d.a)},A(this.c,(this.f.api||\"https://f.fontdeck.com/s/css/js/\")+ea(this.c)+\"/\"+b+\".js\",function(b){b&&a([])})):a([])};var Y=new oa(window);Y.a.c.custom=function(a,b){return new sa(b,a)};Y.a.c.fontdeck=function(a,b){return new Ha(b,a)};Y.a.c.monotype=function(a,b){return new ra(b,a)};Y.a.c.typekit=function(a,b){return new Ga(b,a)};Y.a.c.google=function(a,b){return new Ea(b,a)};var Z={load:p(Y.load,Y)}; true?!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return Z}).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):undefined;}());\n\n\n//# sourceURL=webpack://threeD/C:/Users/XiaoMi/AppData/Roaming/npm/node_modules/webfontloader/webfontloader.js?");

/***/ })

/******/ });